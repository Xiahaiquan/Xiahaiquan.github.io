{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/uploads/wechat-qcode.jpg","path":"uploads/wechat-qcode.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/uploads/wechat-reward-image.jpg","path":"uploads/wechat-reward-image.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"a8f6777e9538d368c322ae63359f1c0ded85df3e","modified":1573001288178},{"_id":"source/_posts/CRC.md","hash":"94b188a6c1f1ad2c312cb5d7339321f9f179f47f","modified":1571833641707},{"_id":"source/_posts/Swift5中CFStringTransform的使用.md","hash":"9a51dbe75c1f01476645e5782881b13dd9e68187","modified":1573001331852},{"_id":"source/_posts/开发Tips.md","hash":"ffd0d58af63263939e5d5940e0516d2c9d330501","modified":1571888774969},{"_id":"source/_posts/重置Mac管理员名称和密码.md","hash":"5e9068c38ce4162960cab38889f66b861106e69b","modified":1569222745104},{"_id":"source/_posts/Nmap的详细说明.md","hash":"f2934c0827cc2e992efa89de6ce7d348f76e7ca7","modified":1569503112626},{"_id":"source/_posts/SwiftLint的使用.md","hash":"9be70dfd24437c7d74cb418ddedb48d7c6497387","modified":1568173293609},{"_id":"themes/next/.all-contributorsrc","hash":"a03f0ccb9b6798679dc2a77e5c395a167ce388c2","modified":1567737014479},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1567737014479},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1567737014479},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1567737014479},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1567737014484},{"_id":"themes/next/README.md","hash":"e0fcd99c0a6db47fe5739df32d6ab39c44c65196","modified":1567737014484},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1567737014484},{"_id":"source/_posts/Nmap的简单使用.md","hash":"9fccb7869a793e502593e2f5e7890761f0c151fc","modified":1569503084045},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1567737014483},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1567737014483},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1567737014484},{"_id":"themes/next/_config.yml","hash":"f2e6360f21e368d4cd8f0b3d19961829ab732e58","modified":1568116555036},{"_id":"themes/next/gulpfile.coffee","hash":"25d1bf7f98ea03c647cb8caa19e109aaaacd6ad7","modified":1567737014490},{"_id":"themes/next/package.json","hash":"4891972e0a53023164ed241966ba93cb0a8c05fc","modified":1567737014509},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1567737014455},{"_id":"themes/next/.git/index","hash":"f45e9a92c72f922d6b44b1b5dfa0bc0e972edc83","modified":1567737014719},{"_id":"themes/next/.git/packed-refs","hash":"148c06a967c9d0c2b57bebd58dc6cbfa47876e1a","modified":1567737014454},{"_id":"themes/next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1567737014473},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1567737014480},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1567736608387},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"d3e864f707c8bf2502579ef279d2c4e8cab8520a","modified":1567737014480},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"88780daa3db837a34fe3ed90cc61cc578b5760ed","modified":1567737014481},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1567737014481},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1567737014482},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1567737014482},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b09c85aa449f46bc025317ed196ec33a877f7c23","modified":1567737014482},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1567737014482},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1567737014482},{"_id":"themes/next/.github/release-drafter.yml","hash":"f8a0ee0ad08e1493475dbb67b2957cd6afcafac0","modified":1567737014483},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1567737014483},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1567737014483},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"38a9b4b86a876ccaba2a3e968df7aa676524429f","modified":1567737014480},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"20f8a3d7db6e797a5a3ed8c84837315cb8e09e5b","modified":1567737014485},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1567737014485},{"_id":"themes/next/docs/AUTHORS.md","hash":"44c3b963d877c6cbc3a720ed4e266532db3c12ac","modified":1567737014486},{"_id":"themes/next/docs/DATA-FILES.md","hash":"a85ae0f3a9655eea9acd3f6209b72eb002f2058d","modified":1567737014486},{"_id":"themes/next/docs/INSTALLATION.md","hash":"5385246ab4756e3e26ec9fe1f6a6759812177cc4","modified":1567737014486},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"1fb2c852fad03b73882069f1ec0659db2e1f2da0","modified":1567737014486},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1567737014486},{"_id":"themes/next/docs/MATH.md","hash":"aa90364b1ac069b4f8cfdb48b4879311856224e6","modified":1567737014487},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"a07ca23c38f6e4dddd4b74016b30e88cd3796f75","modified":1567737014487},{"_id":"themes/next/languages/de.yml","hash":"3d8920676d89494d7d1c74d4238680151ea6d9df","modified":1567737014490},{"_id":"themes/next/languages/en.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1567737014490},{"_id":"themes/next/languages/default.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1567737014490},{"_id":"themes/next/languages/es.yml","hash":"7dc1d7d5ea1078ee3b9bc8e0e8d0f15f52a7a4aa","modified":1567737014490},{"_id":"themes/next/languages/fr.yml","hash":"dfdcfa536c40d06125dff373d042c50e08fcafd8","modified":1567737014491},{"_id":"themes/next/languages/fa.yml","hash":"269b5cb70774485d7dbbcf98eec72c9e84e135b2","modified":1567737014491},{"_id":"themes/next/languages/hu.yml","hash":"e4a5f43fb45acd992def3de3b600aa4df4c95ed7","modified":1567737014491},{"_id":"themes/next/languages/id.yml","hash":"5665dece8435964a27b5061d7283f339f84721f0","modified":1567737014491},{"_id":"themes/next/languages/it.yml","hash":"311597c620059dbb99474f19b2110a4485ecf70b","modified":1567737014491},{"_id":"themes/next/languages/ja.yml","hash":"4f929842b3d6aaed709ea99da679d3910ee184e5","modified":1567737014492},{"_id":"themes/next/languages/nl.yml","hash":"561c77ca68e9d51a5ce8c89d3361fdb033c96bba","modified":1567737014492},{"_id":"themes/next/languages/ko.yml","hash":"5f5194dd0f5a3c8484e7668bce6fbe23340e531a","modified":1567737014492},{"_id":"themes/next/languages/pt-BR.yml","hash":"13b579911e44a8b213e1860f9a50c341be1bf95e","modified":1567737014492},{"_id":"themes/next/languages/pt.yml","hash":"af9d9b581dca45ab9789ca41d3492883a911e383","modified":1567737014492},{"_id":"themes/next/languages/ru.yml","hash":"b485c57dd7b447406dafd0dcfdfc9356266708c9","modified":1567737014493},{"_id":"themes/next/languages/tr.yml","hash":"39caf8a3677fd6dfbd523e73f8482a509e87b603","modified":1567737014493},{"_id":"themes/next/languages/uk.yml","hash":"4cbdbb0ed09487c9b435be21ac35f62182f53283","modified":1567737014493},{"_id":"themes/next/languages/vi.yml","hash":"3c6bb816ee7278afcddac06998c9ebe47ee19aef","modified":1567737014493},{"_id":"themes/next/languages/zh-CN.yml","hash":"e92e1e07a89c9fab27f445f9ec0fa35049fef38c","modified":1567737014493},{"_id":"themes/next/languages/zh-HK.yml","hash":"93d10d6e448c519004b09b11fba980b5036c93af","modified":1567737014493},{"_id":"themes/next/languages/zh-TW.yml","hash":"ae2aa1c6ec1a5a01a3a3bde17bcc3a82f9a35fa7","modified":1567737014494},{"_id":"themes/next/source/.DS_Store","hash":"4f9aa800fd2f8e633bb6be75c0842e524a8929a0","modified":1568086454094},{"_id":"themes/next/layout/.DS_Store","hash":"1263cde9e734f6b27828856f87bdee36bf553ec5","modified":1568087635511},{"_id":"themes/next/layout/_layout.swig","hash":"aa94f42953d9ef363dd644ef9ea7571bddb0d4ca","modified":1567737014494},{"_id":"themes/next/layout/archive.swig","hash":"72b4e0786668bc61c11eafa12da5d75272b93b61","modified":1567737014508},{"_id":"themes/next/layout/index.swig","hash":"20e776e8863f662c154bb765aaa0a1a22bf78126","modified":1567737014508},{"_id":"themes/next/layout/category.swig","hash":"38433a9de15f019267c9130e243e14343fb9bc3d","modified":1567737014508},{"_id":"themes/next/layout/page.swig","hash":"f038deec70adfecb0a87256ba8c319d4781925a5","modified":1567737014509},{"_id":"themes/next/layout/tag.swig","hash":"153fb65e710a9643634aea4813431e92c11d09fe","modified":1567737014509},{"_id":"themes/next/layout/post.swig","hash":"0c3b34a6832b8e33574edc17095344f9e0bea74f","modified":1567737014509},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1567736608389},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1567736608388},{"_id":"themes/next/source/404.html","hash":"ba80375b0cba4d32e509ddb9033b2be421dc78c7","modified":1568023026540},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1567736608389},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1567736608391},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1567736608390},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1567736608389},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1567736608390},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1567736608388},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1567736608391},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1567736608390},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1567736608387},{"_id":"themes/next/.git/logs/HEAD","hash":"8230d69f4b84bd204552f0a58e2a6a367aae7f06","modified":1567737014472},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"facdcc87737863ae04aa1c851473c5df8dfc05ed","modified":1567737014481},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"ddec22254fb69a7aedef3be3e5142347591ed04b","modified":1567737014481},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"5b814a4462e5a19dca7d78ffd158a5f74e812467","modified":1567737014481},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"b5c646d5932039eb22c28fd80fde54e02079f0d1","modified":1567737014481},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1567736608391},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"67d04e3e29a2675d1a9f87d1ae6ea0769e963ff1","modified":1567737014487},{"_id":"themes/next/docs/ru/README.md","hash":"3ceab62de4db29e2257dd5a187c7f8731a207f84","modified":1567737014488},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1567737014488},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"5ad2c2d0a11443a03b3fd912925bc0dcfbcda88c","modified":1567737014488},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0dfb458370a0ffbbe37c00f53c15e3aa3e79b125","modified":1567737014488},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"ca39e510b43ea1efe7e5feeca2243375e55eff5c","modified":1567737014488},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"c46f3f7496fc422207cc5954e10a2bc972b650aa","modified":1567737014489},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"c13546dd70a99a7d2d409cddf5d59f2f4d4d44a4","modified":1567737014489},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"a658a72589738e11aefaa3a714b188ffd5aac822","modified":1567737014489},{"_id":"themes/next/docs/zh-CN/README.md","hash":"0981aaf68145a05b02cd10c95d38cbaf97622944","modified":1567737014489},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8ceaad956a1afedf179b2e0b98a67adee9afec08","modified":1567737014489},{"_id":"themes/next/scripts/events/index.js","hash":"a25690d8b03779f7e318108c8eace9baf6d4283a","modified":1567737014509},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"4ee0607ddcfb2fe0e5868aced6d5814d1ada4405","modified":1567737014490},{"_id":"themes/next/scripts/helpers/engine.js","hash":"896a581feb9432e58a325ad04d66d6310a12374e","modified":1567737014513},{"_id":"themes/next/scripts/helpers/font.js","hash":"53169e2d04f0c21e68beb07c212be0a6c2a9aaea","modified":1567737014513},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1567737014487},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1567737014514},{"_id":"themes/next/scripts/helpers/next-inject.js","hash":"33eb6f38de575b973fed237032c34d878594fdc1","modified":1567737014513},{"_id":"themes/next/scripts/helpers/next-js.js","hash":"b28a8ed6d033946acbb5b91f6d8b884857410dd9","modified":1567737014514},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"834599d2b83f06e90f8cf618cddc106fe900ba5c","modified":1567737014512},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"d512f44195f68b0ff93f3c82afff9161cdf1b7d6","modified":1567737014514},{"_id":"themes/next/scripts/filters/excerpt.js","hash":"827c3733fa14b018dd1f07e41686c207880e823a","modified":1567737014512},{"_id":"themes/next/scripts/filters/exturl.js","hash":"9c32675f64121ffbe454189b8e418b408f79d9c2","modified":1567737014512},{"_id":"themes/next/scripts/filters/lazyload.js","hash":"51672320fff6b39f56fe6a2881c611afe4e79b8e","modified":1567737014513},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1567737014514},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1567737014513},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1567737014514},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1567737014514},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"60f880c1e11a7df1aee4f2e01d65451fecc0372c","modified":1567737014515},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1567737014515},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1567737014515},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1567737014515},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1567737014515},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1567737014516},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1567737014516},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1567737014516},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1567737014536},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1567737014536},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1567737014536},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1567737014537},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1567737014537},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1567737014538},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1567737014537},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1567737014538},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1567737014538},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1567737014538},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1567737014539},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1567737014539},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1567737014539},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1567737014539},{"_id":"themes/next/source/css/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1568027990865},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1567737014539},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1567737014540},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1567737014559},{"_id":"themes/next/source/js/bookmark.js","hash":"39b0022f8ee6c6d443affdbf8608a86155fbf8f4","modified":1567737014540},{"_id":"themes/next/source/js/local-search.js","hash":"0579159bf994e3726b3ba063e5905f79465fdfb1","modified":1567737014540},{"_id":"themes/next/source/js/next-boot.js","hash":"2294cdcc61f265388c02955e86ff74641d18915a","modified":1567737014540},{"_id":"themes/next/source/js/motion.js","hash":"d52807a73efc34b1189c096477f348d05debf861","modified":1567737014540},{"_id":"themes/next/source/js/utils.js","hash":"1647843f7923e66e2d196c4c6ec1975d6f051917","modified":1567737014541},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"1bb927e0560d3d3c95369da461911cced5bd537b","modified":1567737014494},{"_id":"themes/next/layout/_macro/post.swig","hash":"76788b119076b1f28e8bac453be3e6b66e169792","modified":1567737014495},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"ccef7a8cd704575cf7bfe63c0492fe43592b1a6d","modified":1567737014495},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1567737014538},{"_id":"themes/next/layout/_partials/footer.swig","hash":"9d9a5d6a2f0d4f65fe57c3737c91ecaf276c1f5c","modified":1567737014497},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"769a983fe2f77908bfc8590ff37a0d8958b47598","modified":1567737014498},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"5e0f7897920ad2bd1545b28ccf2399d2436cafc3","modified":1568087693601},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"4b0c972c44bfa7ab07604280563deb9cc3974657","modified":1567737014499},{"_id":"themes/next/layout/_partials/comments.swig","hash":"02ca8ced747937a4972df599ad5f56cb85f2afa8","modified":1568084152737},{"_id":"themes/next/source/uploads/wechat-qcode.jpg","hash":"86decac6230c7ec23a01d06ec0f55706eecdd0e7","modified":1568029144562},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"58f12810a730ba8e3129c9b0d1a7cce42ac6f2d2","modified":1567737014500},{"_id":"themes/next/layout/_third-party/facebook-sdk.swig","hash":"3cf1a1a83ceddef4033a2964150f81b979ced6ff","modified":1567737014505},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1567737014504},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"65f94b115c42d33e6a90b1f8e62075c6d4ac60c1","modified":1567737014506},{"_id":"themes/next/layout/_third-party/vkontakte-api.swig","hash":"e0d012bdbae5545d90143030116114c34219bd37","modified":1567737014508},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1567737014506},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1567737014501},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"e08feac6f8904d7f2006e350514a2f07eb9fff44","modified":1567737014501},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"105004ddcc7fe9f4fd7ad1007b628ba8c08c1e27","modified":1567737014501},{"_id":"themes/next/layout/_scripts/three.swig","hash":"eee4d26b5c0bb7872a21346151c38612a9b76d0b","modified":1567737014502},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"d3448044776dd23abd42b09ef0f26827f95efdf5","modified":1567737014502},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567737014529},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567737014529},{"_id":"themes/next/layout/_third-party/gitalk.swig","hash":"a95c53e6a5878c968e00472166512788e6a6d424","modified":1568032453099},{"_id":"themes/next/layout/_third-party/index.swig","hash":"f4f6c09c748fb513b66bce0e6c53cde9b37c0156","modified":1568084261790},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b710d896fccd34657a70244645470e476a4e069f","modified":1567737014510},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"2a5f7c7e507bb354ec05a881bc9a1f4f2f28197c","modified":1567737014510},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1567737014510},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"3ac62f5510f22e9d970089bb01f96ba2134ae161","modified":1567737014510},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1567737014510},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"ccfac51bde0063ab7ef88182f8cbc98c210e78c9","modified":1567737014511},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1567737014511},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"178c4618b29a1e06221285146071e72e24c40499","modified":1567737014511},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1567737014511},{"_id":"themes/next/scripts/filters/comment/facebook-comments-plugin.js","hash":"e3c74b24f3818f2504fd0c7a954adaa6681bb969","modified":1567737014511},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1567737014511},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"e34d38aee93558b2c68a7fa6203c2e4806405d62","modified":1567737014512},{"_id":"themes/next/scripts/filters/comment/vkontakte.js","hash":"031337c2e2157628a15a5f4d96fa6e3fcf2733fe","modified":1567737014512},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1567737014529},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1567737014529},{"_id":"themes/next/source/images/avatar.jpg","hash":"72a2d8a0ea049f348c72d6fda96d8998003fe06c","modified":1568021897245},{"_id":"themes/next/.git/refs/heads/master","hash":"ce7373aa4687b9ec3c3f440001cdc87eebbcbdda","modified":1567737014472},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"59384f63e608b272e4c8679009bbe5e6594fd1b1","modified":1567737014529},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"14e4bd0bd702c7a7f83bf7d529fade2d0634c2f1","modified":1567737014533},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"d9a2eff154fafff547b3aca7321eee94b450c00a","modified":1567737014533},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"1e99dfbe7736acfee59d6f54dbd6b33ddfe2fe8a","modified":1567737014533},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"db52bce619bb848189e83b7bfabd1b2a06fd5578","modified":1567737014533},{"_id":"themes/next/source/css/_variables/base.styl","hash":"639b65a486154cf1f70c31f3fff440ce022255c0","modified":1567737014533},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1567737014559},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1567737014559},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1567737014559},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1567737014560},{"_id":"themes/next/source/js/schemes/muse.js","hash":"be8471d4a84b773014b46a3650887ab55116ea68","modified":1567737014541},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"9e959646899a1dd381c0bea870408cd392c93c70","modified":1567737014494},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1567737014560},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"1dc3875981923aee38b7b1e3ca3813b75ed6ab9c","modified":1567737014494},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"1e47ffdda23f7f645a2a883a90e2e9d9ddbf9a46","modified":1567737014541},{"_id":"themes/next/layout/_partials/analytics/busuanzi-counter.swig","hash":"b35b2bf2ce3d73cabe8c443a45c2a82d45baf151","modified":1567737014495},{"_id":"themes/next/layout/_partials/analytics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1567737014495},{"_id":"themes/next/layout/_partials/analytics/firestore.swig","hash":"67e63c25d509f02a6057ee9724f1b6efd647f72f","modified":1567737014496},{"_id":"themes/next/layout/_partials/analytics/index.swig","hash":"ac6a3995c1330d2d73300b2427006509d0f8dba5","modified":1567737014496},{"_id":"themes/next/layout/_partials/analytics/lean-analytics.swig","hash":"fb7729b69ef443db1f3f2755506ee998cfe4b973","modified":1567737014496},{"_id":"themes/next/layout/_partials/analytics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1567737014496},{"_id":"themes/next/layout/_partials/analytics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1567737014496},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"0edd29b972aceecccb65b3e63d79c01f6639d0c5","modified":1567737014497},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1567737014498},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"6236a874b93ac1be56fc21df8534a7ae8acffcfc","modified":1567737014497},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"d3c25d70f0fd76121e4cacb9f8af4ccbe2a3c74d","modified":1567737014498},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"9718d372887f4b0ee952da42d10b2f736d0fc6de","modified":1567737014497},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"e0767e09a632264f189570e95ccf70fb1dad9110","modified":1567737014497},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"1ba4cd71b826186b7f782bd06258f2ec52a2b491","modified":1567737014498},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"c3a484d7bb15b55e4e48d412b0b30981168be6f3","modified":1567737014498},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"b68ccb90e2ee42bd98c93fc030a29d38689dd55c","modified":1567737014499},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"b654d63d2ed221a8b642223e220392e5172d8f4d","modified":1567737014499},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f05225f7d0ada3853c425899b515056b96ca49bf","modified":1567737014499},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"90a0869c6cc351d92fc97bf42fdc6e1bfa6bc513","modified":1567737014499},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"2edfaf1579ea58e15cb5583fb7962dfee9af2257","modified":1567737014500},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1567737014500},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1567737014500},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1567737014500},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"4e71b26d91ab750791f3be6035a946eb96ca7b34","modified":1567737014500},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"7fd0459d2f1cfe1254f2c2b8087dc094c8cb0e84","modified":1567737014503},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1567737014503},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"9f73476ebcf5cd3b7f55525b3f35dc7e9f01e154","modified":1567737014503},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"42aa3022f7739a552c7a55de316d8c0994b2fdc1","modified":1567737014503},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"20fcbed44aede1b908bd17d7a0279b03639068b1","modified":1567737014503},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1567737014504},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"86092b31761948486ecb379eb7445f66a158769d","modified":1567737014505},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"df8413cba22deffca94cf4edd6d9f8d35d2bb58f","modified":1567737014505},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ab937195168a0e8a911bf5730307f680e6d521e9","modified":1567737014505},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1567737014505},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1567737014504},{"_id":"themes/next/layout/_third-party/chat/index.swig","hash":"5ab4a8b4306c837d2f8c211a9d7fdaed76fa254d","modified":1567737014504},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"bc23c9eb9c06b0b377695f44373c14c5cde1d0e3","modified":1567737014506},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1567737014504},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"b9d7a99534e9c2608765b958eae3b5c50f5e4889","modified":1567737014506},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"dff6835d0b03ecc2db6919ca27cfb7b63949e6a8","modified":1567737014506},{"_id":"themes/next/layout/_third-party/tags/index.swig","hash":"83d0a8f71878c6b96a04ba08567b9064de6cce83","modified":1567737014507},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"a54308f934c33b12f6bf28e4ce90e517f38cab57","modified":1567737014507},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7597800b6ce2f545baea797d95d1b8c7cf624299","modified":1567737014508},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"ad7a22ee0f183481c7843ecd881b9f9e8e037e31","modified":1567737014507},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"eab6d3bee19b1501250de8f6bbb828abe8cffa1a","modified":1568087766386},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"b2fd17688f0433571b37704bc8df798e175e7811","modified":1567737014507},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1567737014507},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1567737014507},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1567737014502},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"9e44c795565837ba318fd739e42713de365673fd","modified":1567737014501},{"_id":"themes/next/layout/_partials/post/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1568087930255},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1567737014502},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1567737014502},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"a95c53e6a5878c968e00472166512788e6a6d424","modified":1568032453099},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1567737014502},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1567737014718},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1567737014718},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1567737014455},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"8230d69f4b84bd204552f0a58e2a6a367aae7f06","modified":1567737014472},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"71d75fa309cf5b96d876da536f57c047e57afcff","modified":1567737014530},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"87d19a45db10689aae9a09736efd1eb896a35b3d","modified":1567737014530},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"3462ffd270f3e218e0a8362262466e79d731f975","modified":1567737014530},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"c42802ecca44d4ea435c26700070a65375edfd7c","modified":1567737014530},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"73fe940abb0787a19f505fb614aafe73c8a24f08","modified":1567737014530},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"dc2a3217f9b50cf42c4262c9e486281203eaef83","modified":1567737014530},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"e859283440617f18f1ad298f7f1218aafa9b39d5","modified":1567737014531},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"54c5e23ec3dcbbc77848ededba76e861cf0f4719","modified":1567737014531},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1567737014531},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b22583b7340c2686a46aefeeed086540b08324a3","modified":1567737014531},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1567737014531},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"41b1d10a530913908e026fd991216e234766d148","modified":1567737014531},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1567737014532},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"2ab9e0499f241d1b91e2f7722072d23c95104e1f","modified":1567737014532},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"ac523812bebb13cde268dc3cde65d0b7c6862e30","modified":1567737014532},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44ac3dff65c1bd3fe47feeed8e58aa00c9f2fb7b","modified":1567737014532},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"3bcb47b9b9ea671e0a3cba6a821045d3434734cb","modified":1567737014532},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"10b4794ba62726fc052c74d786d962ed79d0780b","modified":1567737014532},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"cda066b495a4b6b10c7bc88b2a9b82722156b66b","modified":1567737014516},{"_id":"themes/next/source/uploads/wechat-reward-image.jpg","hash":"34e88299ee1393146095c7886c5e711535b87fd9","modified":1568086814000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"e0db0d9205cd47c48edba81c7397e09ed24783fa","modified":1567737014516},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"060aeb5cff414014f7cdbb61e0ec7855cb0d4b32","modified":1567737014517},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1567737014517},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"674c32b6e9df4b2294df07c3966bf6555e0fb5ad","modified":1567737014520},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"6c61a120d61dec145c8db3a244cae0e724f6f3ef","modified":1567737014517},{"_id":"themes/next/source/css/_common/components/.DS_Store","hash":"0d8e15a88d6febfb1b2fc72d885e2ffb7f18d4d9","modified":1568103434812},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"8e9deaf1e0a27d5bf5f0401bf04f5637df12b6c4","modified":1567737014523},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"0dd11537a4b9a4d2faf3ad5cdae0f0f770a99ccf","modified":1567737014523},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"202ee1f1f8e64d8292df16f40ee176ff4e5d7e71","modified":1567737014523},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"b6b9dc8a350e51ad7b8bb08141a61fc2fd7466fc","modified":1567737014527},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"cb25eed35117be256ea7a573fec2cdfb66901dbb","modified":1567737014528},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"0c60cf489cd083d3a1e3502a240a761b656241c2","modified":1567737014528},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"c4a5c52e30444602237530f379c1707ec864fa9a","modified":1567737014528},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"4f7140cc0db08b47a25c4c7aad71047d433051a1","modified":1567737014528},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"19a20393d266b21ee44ff07d6fa1e9ebbc39a5d9","modified":1567737014528},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"4ddbc8b2dba6fad900c5eca793a31f18ba850f5a","modified":1567737014529},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1567737014560},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1567737014560},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1567737014561},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"8230d69f4b84bd204552f0a58e2a6a367aae7f06","modified":1567737014455},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"caf2abcffa5674adea300046fd3dbee2e830b40e","modified":1567737014517},{"_id":"themes/next/source/css/_common/components/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1567737014517},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"386fce803e5240c2d6860ae53f38ae3aa2e8b680","modified":1567737014518},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"1bfa07d40ceb03b0b69a5752478ca555723f7a15","modified":1567737014518},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1567737014518},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"139c17e7d4aa3e1112340a26a270efe58c279f8e","modified":1567737014518},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"dada73ae88f01fab2ab4d2c83eddfc558de2110a","modified":1567737014518},{"_id":"themes/next/source/css/_common/components/highlight/copy-code.styl","hash":"2124abd41b69ff152f4bb39e78d8fbce96a45c65","modified":1567737014519},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"4718d17fc4ee30802925890771a032d966133a31","modified":1567737014518},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1567737014519},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4efe9174369bfe2125bd167feac18a07271635d6","modified":1567737014519},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"a67dc85f6d158dac20e951ab55988ff7e9e1739b","modified":1567737014519},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1567737014519},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1567737014520},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1567737014520},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"919cc9aaf60b03c2bf00aca3748127f38a2026cf","modified":1567737014520},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1567737014520},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1567737014521},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"db718eee14347f30ccabaa33bf6f9fbdea8b9462","modified":1567737014521},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"3abf46c513e92f3f36c14d90f032983b94f36488","modified":1567737014521},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1567737014521},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"caa9a78993d549117cdc8fa7a76c473a5e7f0f67","modified":1567737014521},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"c60afb603d58cad3ad13e1a16c66832538510063","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"541d6257023915a7caca7540f12cdf283ce025f3","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"469d5e4e188f484abff24eddd5640fa4d4d77ed1","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"5da763d541540586ccd13868a36e3da55549eb22","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"8b6481a0ac60007cf3defa3c9d85a6e412c91d6e","modified":1567737014522},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"e77986ca3b914348b5c3c6b34c94b49ad53e4b9c","modified":1567737014523},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"ac2105c5a7f581b1c0f2b59f2c0c3e87a7c28383","modified":1567737014521},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1567737014527},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"85b8606763f4177d2f9a11c1909a21ab1ae2011c","modified":1567737014527},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"38ce7d692b8bc6fde02e3271dfd50ad37e107e4e","modified":1567737014527},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"4525465f40f82bd66e5f34e986440c75a9e2d2b2","modified":1567737014527},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1567737014709},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1567737014718},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"0527bc64708a9446dc7bbb2c7e39ab3a61251c26","modified":1567737014525},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"e995515580fc467a05946b8b7c0abf97e8481735","modified":1568103469375},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"78d309e22206a4addda3c393282518dae02250ed","modified":1567737014526},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"514999bde116ef5cd5f7aedea80059b12a87a1ea","modified":1567737014525},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"754f70161b7e810f582cc4755d177859dcbcfced","modified":1567737014526},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1567737014526},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1567737014526},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"a1eed8fe7f97885a9234502a197abf2e90ba22b6","modified":1567737014526},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1567737014524},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1567737014524},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"41ccae779f918e6f9f5f625789a7360f1362454c","modified":1567737014524},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2ef546b4cfa5038ebb050c592c5135bbeb51af41","modified":1567737014523},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"d055f8420583c7a009818dcdfaada592308bd628","modified":1567737014524},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"db44ef2b99fc33d003010f38e64caad930c08ad0","modified":1567737014524},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"782cf8847c9aca96f9194fcf1d910509e4073ce6","modified":1567737014525},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"f3108a247549fbdf11071d023add3f1b34ad2b23","modified":1567737014524},{"_id":"themes/next/.git/objects/pack/pack-d12fe731d8bc1ed76a135e3d2fe339036483626d.idx","hash":"1148d6115d654369c407a19d1f7963c4f4e82321","modified":1567737014108},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"17c3f58fb84453603621d6a718fcc821c8d6bced","modified":1567737014525},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"02e5a998748a67fa885fb06fae242bcf3f2786fb","modified":1567737014525},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1567737014661},{"_id":"themes/next/.git/objects/pack/pack-d12fe731d8bc1ed76a135e3d2fe339036483626d.pack","hash":"746bc2c0a033d1bd10ef7986a3f39bdb467bf91c","modified":1567737014066},{"_id":"public/archives/index.html","hash":"ebaecd4bc5fc676a99831a1676583a0789f54a60","modified":1573001352278},{"_id":"public/2019/09/23/重置Mac管理员名称和密码/index.html","hash":"8dbbafa4cc44aba81715514d2a091ab0b65c64a0","modified":1573001352278},{"_id":"public/archives/2019/index.html","hash":"67bd69f9ca5fad6b9ab3333836a14f403cdc03a0","modified":1573001352278},{"_id":"public/archives/2019/10/index.html","hash":"9442870e83d6dcdcaa48e400b26ac6c65a925531","modified":1573001352278},{"_id":"public/archives/2019/09/index.html","hash":"749cff1cdfb4d9495b3241ebd37a38d5210f4fb9","modified":1573001352278},{"_id":"public/archives/2019/11/index.html","hash":"3961ca98af8526ced72a28ae42fd2f0764b1eb76","modified":1573001352278},{"_id":"public/tags/iOS开发中的小技巧/index.html","hash":"9cb7b6169ad5f4916dd9f48738ff172eec3b1859","modified":1573001352278},{"_id":"public/tags/知识点记录/index.html","hash":"973c6f1e701a0f750b1d18713f6592af248f2023","modified":1573001352278},{"_id":"public/tags/第三方的使用/index.html","hash":"d126aa0e89eff9c16c47bc7a525aeb6f9d896c5b","modified":1573001352279},{"_id":"public/tags/工具的使用/index.html","hash":"32ace7e82ac6ae82f3df2b05c1dfc320fbc87493","modified":1573001352279},{"_id":"public/tags/软件、工具的使用/index.html","hash":"80042015038209bcde7eac76c73ddda8dd2c4b87","modified":1573001352279},{"_id":"public/2019/11/06/Swift5中CFStringTransform的使用/index.html","hash":"7c9ca9584974ee36ebf137cac8bd4009db0a02a2","modified":1573001352279},{"_id":"public/2019/10/23/CRC/index.html","hash":"5eb5d3f87ba836d3e3f6dca29aa3cdfb10259f65","modified":1573001352279},{"_id":"public/2019/09/26/Nmap的简单使用/index.html","hash":"06301e5f02c91918e25b6cabb4f4358d5340d791","modified":1573001352279},{"_id":"public/2019/09/10/SwiftLint的使用/index.html","hash":"87e3e00f0bae6900e261d71e6ff7588cb9a0dfcc","modified":1573001352279},{"_id":"public/index.html","hash":"a11488f463e1b6daa83b0c16de397a1bc39f6d19","modified":1573001352279},{"_id":"public/2019/09/26/Nmap的详细说明/index.html","hash":"1a5e3b48071e21c592f8c7baeaf10f602aea39e4","modified":1573001352279},{"_id":"public/2019/10/22/开发Tips/index.html","hash":"9b121801036d95eaf88eb6474572c9ae87a44da1","modified":1573001352279},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1573001352283},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1573001352283},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1573001352283},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1573001352284},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1573001352284},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1573001352284},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1573001352284},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1573001352284},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1573001352284},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1573001352284},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1573001352284},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1573001352284},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1573001352284},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1573001352284},{"_id":"public/uploads/wechat-qcode.jpg","hash":"86decac6230c7ec23a01d06ec0f55706eecdd0e7","modified":1573001352284},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1573001352284},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1573001352284},{"_id":"public/images/avatar.jpg","hash":"72a2d8a0ea049f348c72d6fda96d8998003fe06c","modified":1573001352285},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1573001352285},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1573001355187},{"_id":"public/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1573001355218},{"_id":"public/js/next-boot.js","hash":"2294cdcc61f265388c02955e86ff74641d18915a","modified":1573001355218},{"_id":"public/js/motion.js","hash":"d52807a73efc34b1189c096477f348d05debf861","modified":1573001355218},{"_id":"public/js/bookmark.js","hash":"39b0022f8ee6c6d443affdbf8608a86155fbf8f4","modified":1573001355218},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1573001355219},{"_id":"public/js/schemes/pisces.js","hash":"1e47ffdda23f7f645a2a883a90e2e9d9ddbf9a46","modified":1573001355219},{"_id":"public/js/schemes/muse.js","hash":"be8471d4a84b773014b46a3650887ab55116ea68","modified":1573001355219},{"_id":"public/404.html","hash":"463799ef1b241ea13b2d49b696997f67dc4bdee4","modified":1573001355219},{"_id":"public/css/main.css","hash":"3c18ef6d0de959f5466dd558fae335175e94306d","modified":1573001355219},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1573001355219},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1573001355219},{"_id":"public/js/utils.js","hash":"1647843f7923e66e2d196c4c6ec1975d6f051917","modified":1573001355224},{"_id":"public/js/local-search.js","hash":"0579159bf994e3726b3ba063e5905f79465fdfb1","modified":1573001355224},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1573001355224},{"_id":"public/uploads/wechat-reward-image.jpg","hash":"34e88299ee1393146095c7886c5e711535b87fd9","modified":1573001355224},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1573001355228},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1573001355232},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1573001355232},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1573001355232}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"CRC","date":"2019-10-23T11:32:05.000Z","_content":"\n##### CRC（循环冗余校验）\n\n 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种[信道编码技术](https://baike.baidu.com/item/信道编码技术/2366288)，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。\n\n[在线CRC计算工具](http://www.ip33.com/crc.html)\n\n在实际项目中，用于蓝牙数据通讯。一般的做法是在数据的末尾添加CRC校验，用于纠错、检错。\n\n<!-- more -->\n\n##### 计算CRC8的方法\n\n```swift\nimport Foundation\n\nfinal class CRC {\n\n    static let poly = 0x07\n    static let mask = 0xff\n\n    static let table: [UInt8] = {\n\n        var table = Array.init(repeating: UInt8(0), count: 256)\n\n        for i in 0..<table.count {\n            var c = i\n            for _ in 0..<8 {\n                if c & 0x80 != 0 {\n                    c = (((c << 1) & mask) ^ poly)\n                } else {\n                    c <<= 1\n                }\n            }\n            table[i] = UInt8(c)\n        }\n        return table\n    }()\n\n    static func makeCRC8(string: String) -> UInt8 {\n        guard let data = string.data(using: String.Encoding.utf8) else { return 0 }\n        return makeCRC8(data: data)\n    }\n\n    static func makeCRC8(data: Data) -> UInt8 {\n        let dataArray = [UInt8](data)\n        var crc8:UInt8 = 0x00\n        for i in 0..<dataArray.count {\n            crc8 = table[Int(crc8 ^ dataArray[i])]\n        }\n        return crc8\n    }\n\n    static func makeCRC8(data: [UInt8]) -> UInt8 {\n\n        var crc8:UInt8 = 0x00\n        for i in 0..<data.count {\n            crc8 = table[Int(crc8 ^ data[i])]\n        }\n        return crc8\n    }\n\n\n    private init() {\n\n    }\n}\n\n```\n\n###### 使用方法\n\n```swift\nlet bytes: [UInt8] = [0xAA, 0x01, 0x01, 0x03,0x05,0xFF]\n\nlet crcResult = CRC.makeCRC8(data: bytes)\n\nprint(\"crcResult:\\(crcResult)\")\n```\n\n\n\n##### 计算CRC-8/MAXIM的方法\n\n```c\nunsigned char dallas_crc8(const unsigned char * data, const unsigned int size)\n{\n    unsigned char crc = 0;\n    for ( unsigned int i = 0; i < size; ++i )\n    {\n        unsigned char inbyte = data[i];\n        for ( unsigned char j = 0; j < 8; ++j )\n        {\n            unsigned char mix = (crc ^ inbyte) & 0x01;\n            crc >>= 1;\n            if ( mix ) crc ^= 0x8C;\n            inbyte >>= 1;\n        }\n    }\n    return crc;\n}\n```\n\n###### 使用方法\n\n```swift\nvar bytes: [UInt8] = [0xAA, 0x01, 0x01, 0x03,0x05,0xFF]\n\nlet crcResult = dallas_crc8(&bytes, UInt32(Int32(bytes.count)))\n\n print(\"crcResult:\\(crcResult)\")\n```\n\n##### 在Swift中引用C代码\n\n1. 新建文件并创建桥接文件，(可以不创建头文件)将新建的文件后缀名更改为`.m`。\n2. 在`.m`文件中引入桥接文件`#import \"XXTest-Bridging-Header.h\"`, 在该文件中写入C代码。\n3. 在桥接文件中写上C方法签名，`unsigned char dallas_crc8(const unsigned char * data, const unsigned int size)`;\n4. 如上就可在Swift调用C代码了。","source":"_posts/CRC.md","raw":"---\ntitle: CRC\ndate: 2019-10-23 19:32:05\ntags: 知识点记录\n---\n\n##### CRC（循环冗余校验）\n\n 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种[信道编码技术](https://baike.baidu.com/item/信道编码技术/2366288)，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。\n\n[在线CRC计算工具](http://www.ip33.com/crc.html)\n\n在实际项目中，用于蓝牙数据通讯。一般的做法是在数据的末尾添加CRC校验，用于纠错、检错。\n\n<!-- more -->\n\n##### 计算CRC8的方法\n\n```swift\nimport Foundation\n\nfinal class CRC {\n\n    static let poly = 0x07\n    static let mask = 0xff\n\n    static let table: [UInt8] = {\n\n        var table = Array.init(repeating: UInt8(0), count: 256)\n\n        for i in 0..<table.count {\n            var c = i\n            for _ in 0..<8 {\n                if c & 0x80 != 0 {\n                    c = (((c << 1) & mask) ^ poly)\n                } else {\n                    c <<= 1\n                }\n            }\n            table[i] = UInt8(c)\n        }\n        return table\n    }()\n\n    static func makeCRC8(string: String) -> UInt8 {\n        guard let data = string.data(using: String.Encoding.utf8) else { return 0 }\n        return makeCRC8(data: data)\n    }\n\n    static func makeCRC8(data: Data) -> UInt8 {\n        let dataArray = [UInt8](data)\n        var crc8:UInt8 = 0x00\n        for i in 0..<dataArray.count {\n            crc8 = table[Int(crc8 ^ dataArray[i])]\n        }\n        return crc8\n    }\n\n    static func makeCRC8(data: [UInt8]) -> UInt8 {\n\n        var crc8:UInt8 = 0x00\n        for i in 0..<data.count {\n            crc8 = table[Int(crc8 ^ data[i])]\n        }\n        return crc8\n    }\n\n\n    private init() {\n\n    }\n}\n\n```\n\n###### 使用方法\n\n```swift\nlet bytes: [UInt8] = [0xAA, 0x01, 0x01, 0x03,0x05,0xFF]\n\nlet crcResult = CRC.makeCRC8(data: bytes)\n\nprint(\"crcResult:\\(crcResult)\")\n```\n\n\n\n##### 计算CRC-8/MAXIM的方法\n\n```c\nunsigned char dallas_crc8(const unsigned char * data, const unsigned int size)\n{\n    unsigned char crc = 0;\n    for ( unsigned int i = 0; i < size; ++i )\n    {\n        unsigned char inbyte = data[i];\n        for ( unsigned char j = 0; j < 8; ++j )\n        {\n            unsigned char mix = (crc ^ inbyte) & 0x01;\n            crc >>= 1;\n            if ( mix ) crc ^= 0x8C;\n            inbyte >>= 1;\n        }\n    }\n    return crc;\n}\n```\n\n###### 使用方法\n\n```swift\nvar bytes: [UInt8] = [0xAA, 0x01, 0x01, 0x03,0x05,0xFF]\n\nlet crcResult = dallas_crc8(&bytes, UInt32(Int32(bytes.count)))\n\n print(\"crcResult:\\(crcResult)\")\n```\n\n##### 在Swift中引用C代码\n\n1. 新建文件并创建桥接文件，(可以不创建头文件)将新建的文件后缀名更改为`.m`。\n2. 在`.m`文件中引入桥接文件`#import \"XXTest-Bridging-Header.h\"`, 在该文件中写入C代码。\n3. 在桥接文件中写上C方法签名，`unsigned char dallas_crc8(const unsigned char * data, const unsigned int size)`;\n4. 如上就可在Swift调用C代码了。","slug":"CRC","published":1,"updated":"2019-10-23T12:27:21.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke12u0000bfgaq64fz5zl","content":"<h5 id=\"CRC（循环冗余校验）\"><a href=\"#CRC（循环冗余校验）\" class=\"headerlink\" title=\"CRC（循环冗余校验）\"></a>CRC（循环冗余校验）</h5><p> 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种<a href=\"https://baike.baidu.com/item/信道编码技术/2366288\" target=\"_blank\" rel=\"noopener\">信道编码技术</a>，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p>\n<p><a href=\"http://www.ip33.com/crc.html\" target=\"_blank\" rel=\"noopener\">在线CRC计算工具</a></p>\n<p>在实际项目中，用于蓝牙数据通讯。一般的做法是在数据的末尾添加CRC校验，用于纠错、检错。</p>\n<a id=\"more\"></a>\n\n<h5 id=\"计算CRC8的方法\"><a href=\"#计算CRC8的方法\" class=\"headerlink\" title=\"计算CRC8的方法\"></a>计算CRC8的方法</h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CRC</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> poly = <span class=\"number\">0x07</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> mask = <span class=\"number\">0xff</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> table: [<span class=\"type\">UInt8</span>] = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> table = <span class=\"type\">Array</span>.<span class=\"keyword\">init</span>(repeating: <span class=\"type\">UInt8</span>(<span class=\"number\">0</span>), <span class=\"built_in\">count</span>: <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;table.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">c</span> = i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">8</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">c</span> &amp; <span class=\"number\">0x80</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">c</span> = (((<span class=\"built_in\">c</span> &lt;&lt; <span class=\"number\">1</span>) &amp; mask) ^ poly)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">c</span> &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            table[i] = <span class=\"type\">UInt8</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> table</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCRC8</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">UInt8</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> data = string.data(using: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.utf8) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> makeCRC8(data: data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCRC8</span><span class=\"params\">(data: Data)</span></span> -&gt; <span class=\"type\">UInt8</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dataArray = [<span class=\"type\">UInt8</span>](data)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> crc8:<span class=\"type\">UInt8</span> = <span class=\"number\">0x00</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;dataArray.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            crc8 = table[<span class=\"type\">Int</span>(crc8 ^ dataArray[i])]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> crc8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCRC8</span><span class=\"params\">(data: [UInt8])</span></span> -&gt; <span class=\"type\">UInt8</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> crc8:<span class=\"type\">UInt8</span> = <span class=\"number\">0x00</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;data.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            crc8 = table[<span class=\"type\">Int</span>(crc8 ^ data[i])]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> crc8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bytes: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xAA</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x03</span>,<span class=\"number\">0x05</span>,<span class=\"number\">0xFF</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> crcResult = <span class=\"type\">CRC</span>.makeCRC8(data: bytes)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"crcResult:\\(crcResult)\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"计算CRC-8-MAXIM的方法\"><a href=\"#计算CRC-8-MAXIM的方法\" class=\"headerlink\" title=\"计算CRC-8/MAXIM的方法\"></a>计算CRC-8/MAXIM的方法</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> <span class=\"title\">dallas_crc8</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> * data, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> crc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> inbyte = data[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">8</span>; ++j )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> mix = (crc ^ inbyte) &amp; <span class=\"number\">0x01</span>;</span><br><span class=\"line\">            crc &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( mix ) crc ^= <span class=\"number\">0x8C</span>;</span><br><span class=\"line\">            inbyte &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> crc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用方法-1\"><a href=\"#使用方法-1\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bytes: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xAA</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x03</span>,<span class=\"number\">0x05</span>,<span class=\"number\">0xFF</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> crcResult = dallas_crc8(&amp;bytes, <span class=\"type\">UInt32</span>(<span class=\"type\">Int32</span>(bytes.<span class=\"built_in\">count</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">\"crcResult:\\(crcResult)\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"在Swift中引用C代码\"><a href=\"#在Swift中引用C代码\" class=\"headerlink\" title=\"在Swift中引用C代码\"></a>在Swift中引用C代码</h5><ol>\n<li>新建文件并创建桥接文件，(可以不创建头文件)将新建的文件后缀名更改为<code>.m</code>。</li>\n<li>在<code>.m</code>文件中引入桥接文件<code>#import &quot;XXTest-Bridging-Header.h&quot;</code>, 在该文件中写入C代码。</li>\n<li>在桥接文件中写上C方法签名，<code>unsigned char dallas_crc8(const unsigned char * data, const unsigned int size)</code>;</li>\n<li>如上就可在Swift调用C代码了。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h5 id=\"CRC（循环冗余校验）\"><a href=\"#CRC（循环冗余校验）\" class=\"headerlink\" title=\"CRC（循环冗余校验）\"></a>CRC（循环冗余校验）</h5><p> 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种<a href=\"https://baike.baidu.com/item/信道编码技术/2366288\" target=\"_blank\" rel=\"noopener\">信道编码技术</a>，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p>\n<p><a href=\"http://www.ip33.com/crc.html\" target=\"_blank\" rel=\"noopener\">在线CRC计算工具</a></p>\n<p>在实际项目中，用于蓝牙数据通讯。一般的做法是在数据的末尾添加CRC校验，用于纠错、检错。</p>","more":"<h5 id=\"计算CRC8的方法\"><a href=\"#计算CRC8的方法\" class=\"headerlink\" title=\"计算CRC8的方法\"></a>计算CRC8的方法</h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CRC</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> poly = <span class=\"number\">0x07</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> mask = <span class=\"number\">0xff</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> table: [<span class=\"type\">UInt8</span>] = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> table = <span class=\"type\">Array</span>.<span class=\"keyword\">init</span>(repeating: <span class=\"type\">UInt8</span>(<span class=\"number\">0</span>), <span class=\"built_in\">count</span>: <span class=\"number\">256</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;table.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"built_in\">c</span> = i</span><br><span class=\"line\">            <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">8</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">c</span> &amp; <span class=\"number\">0x80</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">c</span> = (((<span class=\"built_in\">c</span> &lt;&lt; <span class=\"number\">1</span>) &amp; mask) ^ poly)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">c</span> &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            table[i] = <span class=\"type\">UInt8</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> table</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCRC8</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">UInt8</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> data = string.data(using: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.utf8) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> makeCRC8(data: data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCRC8</span><span class=\"params\">(data: Data)</span></span> -&gt; <span class=\"type\">UInt8</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dataArray = [<span class=\"type\">UInt8</span>](data)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> crc8:<span class=\"type\">UInt8</span> = <span class=\"number\">0x00</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;dataArray.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            crc8 = table[<span class=\"type\">Int</span>(crc8 ^ dataArray[i])]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> crc8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCRC8</span><span class=\"params\">(data: [UInt8])</span></span> -&gt; <span class=\"type\">UInt8</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> crc8:<span class=\"type\">UInt8</span> = <span class=\"number\">0x00</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;data.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            crc8 = table[<span class=\"type\">Int</span>(crc8 ^ data[i])]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> crc8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bytes: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xAA</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x03</span>,<span class=\"number\">0x05</span>,<span class=\"number\">0xFF</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> crcResult = <span class=\"type\">CRC</span>.makeCRC8(data: bytes)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"crcResult:\\(crcResult)\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"计算CRC-8-MAXIM的方法\"><a href=\"#计算CRC-8-MAXIM的方法\" class=\"headerlink\" title=\"计算CRC-8/MAXIM的方法\"></a>计算CRC-8/MAXIM的方法</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> <span class=\"title\">dallas_crc8</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> * data, <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> crc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> inbyte = data[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">8</span>; ++j )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> mix = (crc ^ inbyte) &amp; <span class=\"number\">0x01</span>;</span><br><span class=\"line\">            crc &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( mix ) crc ^= <span class=\"number\">0x8C</span>;</span><br><span class=\"line\">            inbyte &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> crc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用方法-1\"><a href=\"#使用方法-1\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bytes: [<span class=\"type\">UInt8</span>] = [<span class=\"number\">0xAA</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x03</span>,<span class=\"number\">0x05</span>,<span class=\"number\">0xFF</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> crcResult = dallas_crc8(&amp;bytes, <span class=\"type\">UInt32</span>(<span class=\"type\">Int32</span>(bytes.<span class=\"built_in\">count</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">print</span>(<span class=\"string\">\"crcResult:\\(crcResult)\"</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"在Swift中引用C代码\"><a href=\"#在Swift中引用C代码\" class=\"headerlink\" title=\"在Swift中引用C代码\"></a>在Swift中引用C代码</h5><ol>\n<li>新建文件并创建桥接文件，(可以不创建头文件)将新建的文件后缀名更改为<code>.m</code>。</li>\n<li>在<code>.m</code>文件中引入桥接文件<code>#import &quot;XXTest-Bridging-Header.h&quot;</code>, 在该文件中写入C代码。</li>\n<li>在桥接文件中写上C方法签名，<code>unsigned char dallas_crc8(const unsigned char * data, const unsigned int size)</code>;</li>\n<li>如上就可在Swift调用C代码了。</li>\n</ol>"},{"title":"Swift5中CFStringTransform的使用","date":"2019-11-06T00:48:11.000Z","_content":"\n记一次需求\n\n##### 需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\n\n##### 解决方案: 将歌曲名转换为英文字符，再排序。\n\n<!-- more -->\n\n##### 方案分解：\n\n1. ###### 认识主要iOS中的系统方法。 在Swift中可以使用Core Foundation下的`CFStringTransform`方法转换。\n\n```swift\n// MARK: - 具体的转换方法\n    /// 转换字符串\n    /// - Parameter string: 要转的字符串，需是CFMutableString类型\n    /// - Parameter range: 要转换的区间。全部转换可传入 nil\n    /// - Parameter transform: 要应用的变换\n    /// - Parameter reverse: 是否要反转\n    public func CFStringTransform(_ string: CFMutableString!, _ range: UnsafeMutablePointer<CFRange>!, _ transform: CFString!, _ reverse: Bool) -> Bool\n```\n\n2. ###### 写出调用封装方法。\n\n```swift\nextension String {\n    /// 将任一字符串转换为英文字母字符串\n    func toLetters() -> String {\n\n        let mutableString = NSMutableString(string: self)\n        // 应用 kCFStringTransformToLatin 变换将所有非英文文本转换为拉丁字母表示。\n        CFStringTransform(mutableString, nil, kCFStringTransformToLatin, false)\n        // 应用 kCFStringTransformStripCombiningMarks 变换来去除变音符和重音。\n        CFStringTransform(mutableString, nil, kCFStringTransformStripCombiningMarks, false)\n\n        // 使用CFStringLowercase缩减文本的大小，并使用CFStringTokenizer将文本拆分为标记，以用作文本的索引。\n        let tokenizer = CFStringTokenizerCreate(nil, mutableString, CFRangeMake(0, CFStringGetLength(mutableString)), 0, CFLocaleCopyCurrent())\n\n        var mutableTokens: [String] = []\n        var type: CFStringTokenizerTokenType\n        repeat {\n            type = CFStringTokenizerAdvanceToNextToken(tokenizer)\n            let range = CFStringTokenizerGetCurrentTokenRange(tokenizer)\n            let token = CFStringCreateWithSubstring(nil, mutableString, range) as NSString\n            mutableTokens.append(token as String)\n        } while type != []\n\n        //生成最终字符串\n        let joined = mutableTokens.joined()\n\n        return joined\n\n    }\n}\n\n```\n\n3. ###### 使用封装的方法\n\n   ```swift\n   let string = \"Hello! こんにちは! สวัสดี! مرحبا! 您好!\"\n   \n    print(string.toLetters())\n   ```\n\n4. ###### 使用方法效果\n\n   ```swift\n   Hellokon'nichihaswasdimrhbaninhao\n   ```\n\n5. ###### 注意事项\n\n   1. 核心的方法原理是通过指定[ICU](http://userguide.icu-project.org/transforms/general#TOC-ICU-Transliterators)`\"Any-Latin; Latin-ASCII; Any-Lower\"`一次转换完成的。就是拉丁字符转换为 ASCII，字母全部小写的格式。\n   2. 在字符串的比较方法中要注意要么字符串全大写or全小写。\n\n6. 参考链接\n\n   1. [CFStringTransform 字符转换](https://imliaoyuan.com/2018/01/01/CFStringTransform-字符转换.html)\n   2. [CFStringTransform](","source":"_posts/Swift5中CFStringTransform的使用.md","raw":"---\ntitle: Swift5中CFStringTransform的使用\ndate: 2019-11-06 08:48:11\ntags:\n---\n\n记一次需求\n\n##### 需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\n\n##### 解决方案: 将歌曲名转换为英文字符，再排序。\n\n<!-- more -->\n\n##### 方案分解：\n\n1. ###### 认识主要iOS中的系统方法。 在Swift中可以使用Core Foundation下的`CFStringTransform`方法转换。\n\n```swift\n// MARK: - 具体的转换方法\n    /// 转换字符串\n    /// - Parameter string: 要转的字符串，需是CFMutableString类型\n    /// - Parameter range: 要转换的区间。全部转换可传入 nil\n    /// - Parameter transform: 要应用的变换\n    /// - Parameter reverse: 是否要反转\n    public func CFStringTransform(_ string: CFMutableString!, _ range: UnsafeMutablePointer<CFRange>!, _ transform: CFString!, _ reverse: Bool) -> Bool\n```\n\n2. ###### 写出调用封装方法。\n\n```swift\nextension String {\n    /// 将任一字符串转换为英文字母字符串\n    func toLetters() -> String {\n\n        let mutableString = NSMutableString(string: self)\n        // 应用 kCFStringTransformToLatin 变换将所有非英文文本转换为拉丁字母表示。\n        CFStringTransform(mutableString, nil, kCFStringTransformToLatin, false)\n        // 应用 kCFStringTransformStripCombiningMarks 变换来去除变音符和重音。\n        CFStringTransform(mutableString, nil, kCFStringTransformStripCombiningMarks, false)\n\n        // 使用CFStringLowercase缩减文本的大小，并使用CFStringTokenizer将文本拆分为标记，以用作文本的索引。\n        let tokenizer = CFStringTokenizerCreate(nil, mutableString, CFRangeMake(0, CFStringGetLength(mutableString)), 0, CFLocaleCopyCurrent())\n\n        var mutableTokens: [String] = []\n        var type: CFStringTokenizerTokenType\n        repeat {\n            type = CFStringTokenizerAdvanceToNextToken(tokenizer)\n            let range = CFStringTokenizerGetCurrentTokenRange(tokenizer)\n            let token = CFStringCreateWithSubstring(nil, mutableString, range) as NSString\n            mutableTokens.append(token as String)\n        } while type != []\n\n        //生成最终字符串\n        let joined = mutableTokens.joined()\n\n        return joined\n\n    }\n}\n\n```\n\n3. ###### 使用封装的方法\n\n   ```swift\n   let string = \"Hello! こんにちは! สวัสดี! مرحبا! 您好!\"\n   \n    print(string.toLetters())\n   ```\n\n4. ###### 使用方法效果\n\n   ```swift\n   Hellokon'nichihaswasdimrhbaninhao\n   ```\n\n5. ###### 注意事项\n\n   1. 核心的方法原理是通过指定[ICU](http://userguide.icu-project.org/transforms/general#TOC-ICU-Transliterators)`\"Any-Latin; Latin-ASCII; Any-Lower\"`一次转换完成的。就是拉丁字符转换为 ASCII，字母全部小写的格式。\n   2. 在字符串的比较方法中要注意要么字符串全大写or全小写。\n\n6. 参考链接\n\n   1. [CFStringTransform 字符转换](https://imliaoyuan.com/2018/01/01/CFStringTransform-字符转换.html)\n   2. [CFStringTransform](","slug":"Swift5中CFStringTransform的使用","published":1,"updated":"2019-11-06T00:48:51.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke1540001bfgakt9he8zb","content":"<p>记一次需求</p>\n<h5 id=\"需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\"><a href=\"#需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\" class=\"headerlink\" title=\"需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\"></a>需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。</h5><h5 id=\"解决方案-将歌曲名转换为英文字符，再排序。\"><a href=\"#解决方案-将歌曲名转换为英文字符，再排序。\" class=\"headerlink\" title=\"解决方案: 将歌曲名转换为英文字符，再排序。\"></a>解决方案: 将歌曲名转换为英文字符，再排序。</h5><a id=\"more\"></a>\n\n<h5 id=\"方案分解：\"><a href=\"#方案分解：\" class=\"headerlink\" title=\"方案分解：\"></a>方案分解：</h5><ol>\n<li><h6 id=\"认识主要iOS中的系统方法。-在Swift中可以使用Core-Foundation下的CFStringTransform方法转换。\"><a href=\"#认识主要iOS中的系统方法。-在Swift中可以使用Core-Foundation下的CFStringTransform方法转换。\" class=\"headerlink\" title=\"认识主要iOS中的系统方法。 在Swift中可以使用Core Foundation下的CFStringTransform方法转换。\"></a>认识主要iOS中的系统方法。 在Swift中可以使用Core Foundation下的<code>CFStringTransform</code>方法转换。</h6></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: - 具体的转换方法</span></span><br><span class=\"line\">    <span class=\"comment\">/// 转换字符串</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter string: 要转的字符串，需是CFMutableString类型</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter range: 要转换的区间。全部转换可传入 nil</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter transform: 要应用的变换</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter reverse: 是否要反转</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CFStringTransform</span><span class=\"params\">(<span class=\"number\">_</span> string: CFMutableString!, <span class=\"number\">_</span> range: UnsafeMutablePointer&lt;CFRange&gt;!, <span class=\"number\">_</span> transform: CFString!, <span class=\"number\">_</span> <span class=\"built_in\">reverse</span>: Bool)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><h6 id=\"写出调用封装方法。\"><a href=\"#写出调用封装方法。\" class=\"headerlink\" title=\"写出调用封装方法。\"></a>写出调用封装方法。</h6></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 将任一字符串转换为英文字母字符串</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toLetters</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> mutableString = <span class=\"type\">NSMutableString</span>(string: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 应用 kCFStringTransformToLatin 变换将所有非英文文本转换为拉丁字母表示。</span></span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformToLatin, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 应用 kCFStringTransformStripCombiningMarks 变换来去除变音符和重音。</span></span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformStripCombiningMarks, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用CFStringLowercase缩减文本的大小，并使用CFStringTokenizer将文本拆分为标记，以用作文本的索引。</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> tokenizer = <span class=\"type\">CFStringTokenizerCreate</span>(<span class=\"literal\">nil</span>, mutableString, <span class=\"type\">CFRangeMake</span>(<span class=\"number\">0</span>, <span class=\"type\">CFStringGetLength</span>(mutableString)), <span class=\"number\">0</span>, <span class=\"type\">CFLocaleCopyCurrent</span>())</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> mutableTokens: [<span class=\"type\">String</span>] = []</span><br><span class=\"line\">        <span class=\"keyword\">var</span> type: <span class=\"type\">CFStringTokenizerTokenType</span></span><br><span class=\"line\">        <span class=\"keyword\">repeat</span> &#123;</span><br><span class=\"line\">            type = <span class=\"type\">CFStringTokenizerAdvanceToNextToken</span>(tokenizer)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> range = <span class=\"type\">CFStringTokenizerGetCurrentTokenRange</span>(tokenizer)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> token = <span class=\"type\">CFStringCreateWithSubstring</span>(<span class=\"literal\">nil</span>, mutableString, range) <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\">            mutableTokens.append(token <span class=\"keyword\">as</span> <span class=\"type\">String</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> type != []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成最终字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> joined = mutableTokens.joined()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> joined</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><h6 id=\"使用封装的方法\"><a href=\"#使用封装的方法\" class=\"headerlink\" title=\"使用封装的方法\"></a>使用封装的方法</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> string = <span class=\"string\">\"Hello! こんにちは! สวัสดี! مرحبا! 您好!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">print</span>(string.toLetters())</span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"使用方法效果\"><a href=\"#使用方法效果\" class=\"headerlink\" title=\"使用方法效果\"></a>使用方法效果</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Hellokon'nichihaswasdimrhbaninhao</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h6><ol>\n<li>核心的方法原理是通过指定<a href=\"http://userguide.icu-project.org/transforms/general#TOC-ICU-Transliterators\" target=\"_blank\" rel=\"noopener\">ICU</a><code>&quot;Any-Latin; Latin-ASCII; Any-Lower&quot;</code>一次转换完成的。就是拉丁字符转换为 ASCII，字母全部小写的格式。</li>\n<li>在字符串的比较方法中要注意要么字符串全大写or全小写。</li>\n</ol>\n</li>\n<li><p>参考链接</p>\n<ol>\n<li><a href=\"https://imliaoyuan.com/2018/01/01/CFStringTransform-字符转换.html\" target=\"_blank\" rel=\"noopener\">CFStringTransform 字符转换</a></li>\n<li>[CFStringTransform](</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>记一次需求</p>\n<h5 id=\"需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\"><a href=\"#需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\" class=\"headerlink\" title=\"需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。\"></a>需求：将歌曲排序。歌曲名可能纯为数字、纯中文、纯英文、纯日文、或者各种语言的混合。</h5><h5 id=\"解决方案-将歌曲名转换为英文字符，再排序。\"><a href=\"#解决方案-将歌曲名转换为英文字符，再排序。\" class=\"headerlink\" title=\"解决方案: 将歌曲名转换为英文字符，再排序。\"></a>解决方案: 将歌曲名转换为英文字符，再排序。</h5>","more":"<h5 id=\"方案分解：\"><a href=\"#方案分解：\" class=\"headerlink\" title=\"方案分解：\"></a>方案分解：</h5><ol>\n<li><h6 id=\"认识主要iOS中的系统方法。-在Swift中可以使用Core-Foundation下的CFStringTransform方法转换。\"><a href=\"#认识主要iOS中的系统方法。-在Swift中可以使用Core-Foundation下的CFStringTransform方法转换。\" class=\"headerlink\" title=\"认识主要iOS中的系统方法。 在Swift中可以使用Core Foundation下的CFStringTransform方法转换。\"></a>认识主要iOS中的系统方法。 在Swift中可以使用Core Foundation下的<code>CFStringTransform</code>方法转换。</h6></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: - 具体的转换方法</span></span><br><span class=\"line\">    <span class=\"comment\">/// 转换字符串</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter string: 要转的字符串，需是CFMutableString类型</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter range: 要转换的区间。全部转换可传入 nil</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter transform: 要应用的变换</span></span><br><span class=\"line\">    <span class=\"comment\">/// - Parameter reverse: 是否要反转</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CFStringTransform</span><span class=\"params\">(<span class=\"number\">_</span> string: CFMutableString!, <span class=\"number\">_</span> range: UnsafeMutablePointer&lt;CFRange&gt;!, <span class=\"number\">_</span> transform: CFString!, <span class=\"number\">_</span> <span class=\"built_in\">reverse</span>: Bool)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><h6 id=\"写出调用封装方法。\"><a href=\"#写出调用封装方法。\" class=\"headerlink\" title=\"写出调用封装方法。\"></a>写出调用封装方法。</h6></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 将任一字符串转换为英文字母字符串</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toLetters</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> mutableString = <span class=\"type\">NSMutableString</span>(string: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 应用 kCFStringTransformToLatin 变换将所有非英文文本转换为拉丁字母表示。</span></span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformToLatin, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 应用 kCFStringTransformStripCombiningMarks 变换来去除变音符和重音。</span></span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformStripCombiningMarks, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用CFStringLowercase缩减文本的大小，并使用CFStringTokenizer将文本拆分为标记，以用作文本的索引。</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> tokenizer = <span class=\"type\">CFStringTokenizerCreate</span>(<span class=\"literal\">nil</span>, mutableString, <span class=\"type\">CFRangeMake</span>(<span class=\"number\">0</span>, <span class=\"type\">CFStringGetLength</span>(mutableString)), <span class=\"number\">0</span>, <span class=\"type\">CFLocaleCopyCurrent</span>())</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> mutableTokens: [<span class=\"type\">String</span>] = []</span><br><span class=\"line\">        <span class=\"keyword\">var</span> type: <span class=\"type\">CFStringTokenizerTokenType</span></span><br><span class=\"line\">        <span class=\"keyword\">repeat</span> &#123;</span><br><span class=\"line\">            type = <span class=\"type\">CFStringTokenizerAdvanceToNextToken</span>(tokenizer)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> range = <span class=\"type\">CFStringTokenizerGetCurrentTokenRange</span>(tokenizer)</span><br><span class=\"line\">            <span class=\"keyword\">let</span> token = <span class=\"type\">CFStringCreateWithSubstring</span>(<span class=\"literal\">nil</span>, mutableString, range) <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\">            mutableTokens.append(token <span class=\"keyword\">as</span> <span class=\"type\">String</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> type != []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成最终字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> joined = mutableTokens.joined()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> joined</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><h6 id=\"使用封装的方法\"><a href=\"#使用封装的方法\" class=\"headerlink\" title=\"使用封装的方法\"></a>使用封装的方法</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> string = <span class=\"string\">\"Hello! こんにちは! สวัสดี! مرحبا! 您好!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">print</span>(string.toLetters())</span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"使用方法效果\"><a href=\"#使用方法效果\" class=\"headerlink\" title=\"使用方法效果\"></a>使用方法效果</h6><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Hellokon'nichihaswasdimrhbaninhao</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h6 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h6><ol>\n<li>核心的方法原理是通过指定<a href=\"http://userguide.icu-project.org/transforms/general#TOC-ICU-Transliterators\" target=\"_blank\" rel=\"noopener\">ICU</a><code>&quot;Any-Latin; Latin-ASCII; Any-Lower&quot;</code>一次转换完成的。就是拉丁字符转换为 ASCII，字母全部小写的格式。</li>\n<li>在字符串的比较方法中要注意要么字符串全大写or全小写。</li>\n</ol>\n</li>\n<li><p>参考链接</p>\n<ol>\n<li><a href=\"https://imliaoyuan.com/2018/01/01/CFStringTransform-字符转换.html\" target=\"_blank\" rel=\"noopener\">CFStringTransform 字符转换</a></li>\n<li>[CFStringTransform](</li>\n</ol>\n</li>\n</ol>"},{"title":"开发Tips","date":"2019-10-22T11:33:41.000Z","_content":"\n# Swift\n\n##### 对象数据转字典\n\n通讯录中`UITableView`的数据源.\n\n```swift\nlet arr = [ContactsModel]\nlet res = Dictionary(grouping: arr, by: { $0.name.prefix(1).uppercased()}) // [String:[ContactsModel]]\n```\n\n<!-- more -->\n\n##### 汉字转拼音\n\n```swift\nextension String {\n\n    func transformToPinYin() -> String {\n\n        let mutableString = NSMutableString(string: self)\n        CFStringTransform(mutableString, nil, kCFStringTransformToLatin, false)\n        CFStringTransform(mutableString, nil, kCFStringTransformStripDiacritics, false)\n        let string = String(mutableString)\n        return string.replacingOccurrences(of: \" \", with: \"\")\n    }\n}\n```\n\n#####  Hex to byte \n\n```swift\nextension StringProtocol {\n    var hexa2Bytes: [UInt8] {\n        let hexa = Array(self)\n        return stride(from: 0, to: count, by: 2).compactMap { UInt8(String(hexa[$0..<$0.advanced(by: 2)]), radix: 16) }\n    }}\n}\n```\n\n##### 获取UICollectionView显示的中间的Cell\n\n遵守Scrollview的代理方法\n\n```swift\nfunc scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {\n\n let centerCellIndexPath = dateCollectView!.getMidVisibleIndexPath()\n\n let  horDateSelectorCollectionViewCell = dateCollectView!.cellForItem(at: centerCellIndexPath!) as? FDHorDateSelectorCollectionViewCell\n\t}\n```\n\n对UICollectionViewCell的extension\n\n```swift\nprotocol CollectionVisibleMidCell {}\nextension CollectionVisibleMidCell where Self: UICollectionView {\n\n    func getMidVisibleIndexPath() -> IndexPath? {\n        var visibleRect = CGRect()\n        visibleRect.origin = self.contentOffset\n        visibleRect.size = self.bounds.size\n        let visiblePoint = CGPoint(x: visibleRect.midX, y: visibleRect.midY)\n        guard let indexPath = self.indexPathForItem(at: visiblePoint) else { return nil }\n        return indexPath\n    }\n}\nextension UICollectionView: CollectionVisibleMidCell {}\n\n\n```\n\n\n\n# OC","source":"_posts/开发Tips.md","raw":"---\ntitle: 开发Tips\ndate: 2019-10-22 19:33:41\ntags: iOS开发中的小技巧\n---\n\n# Swift\n\n##### 对象数据转字典\n\n通讯录中`UITableView`的数据源.\n\n```swift\nlet arr = [ContactsModel]\nlet res = Dictionary(grouping: arr, by: { $0.name.prefix(1).uppercased()}) // [String:[ContactsModel]]\n```\n\n<!-- more -->\n\n##### 汉字转拼音\n\n```swift\nextension String {\n\n    func transformToPinYin() -> String {\n\n        let mutableString = NSMutableString(string: self)\n        CFStringTransform(mutableString, nil, kCFStringTransformToLatin, false)\n        CFStringTransform(mutableString, nil, kCFStringTransformStripDiacritics, false)\n        let string = String(mutableString)\n        return string.replacingOccurrences(of: \" \", with: \"\")\n    }\n}\n```\n\n#####  Hex to byte \n\n```swift\nextension StringProtocol {\n    var hexa2Bytes: [UInt8] {\n        let hexa = Array(self)\n        return stride(from: 0, to: count, by: 2).compactMap { UInt8(String(hexa[$0..<$0.advanced(by: 2)]), radix: 16) }\n    }}\n}\n```\n\n##### 获取UICollectionView显示的中间的Cell\n\n遵守Scrollview的代理方法\n\n```swift\nfunc scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {\n\n let centerCellIndexPath = dateCollectView!.getMidVisibleIndexPath()\n\n let  horDateSelectorCollectionViewCell = dateCollectView!.cellForItem(at: centerCellIndexPath!) as? FDHorDateSelectorCollectionViewCell\n\t}\n```\n\n对UICollectionViewCell的extension\n\n```swift\nprotocol CollectionVisibleMidCell {}\nextension CollectionVisibleMidCell where Self: UICollectionView {\n\n    func getMidVisibleIndexPath() -> IndexPath? {\n        var visibleRect = CGRect()\n        visibleRect.origin = self.contentOffset\n        visibleRect.size = self.bounds.size\n        let visiblePoint = CGPoint(x: visibleRect.midX, y: visibleRect.midY)\n        guard let indexPath = self.indexPathForItem(at: visiblePoint) else { return nil }\n        return indexPath\n    }\n}\nextension UICollectionView: CollectionVisibleMidCell {}\n\n\n```\n\n\n\n# OC","slug":"开发Tips","published":1,"updated":"2019-10-24T03:46:14.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke1650003bfga2xmpivhf","content":"<h1 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h1><h5 id=\"对象数据转字典\"><a href=\"#对象数据转字典\" class=\"headerlink\" title=\"对象数据转字典\"></a>对象数据转字典</h5><p>通讯录中<code>UITableView</code>的数据源.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"type\">ContactsModel</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"type\">Dictionary</span>(grouping: arr, by: &#123; $<span class=\"number\">0</span>.name.<span class=\"keyword\">prefix</span>(<span class=\"number\">1</span>).uppercased()&#125;) <span class=\"comment\">// [String:[ContactsModel]]</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h5 id=\"汉字转拼音\"><a href=\"#汉字转拼音\" class=\"headerlink\" title=\"汉字转拼音\"></a>汉字转拼音</h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transformToPinYin</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> mutableString = <span class=\"type\">NSMutableString</span>(string: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformToLatin, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformStripDiacritics, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> string = <span class=\"type\">String</span>(mutableString)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> string.replacingOccurrences(of: <span class=\"string\">\" \"</span>, with: <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Hex-to-byte\"><a href=\"#Hex-to-byte\" class=\"headerlink\" title=\"Hex to byte\"></a>Hex to byte</h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">StringProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hexa2Bytes: [<span class=\"type\">UInt8</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> hexa = <span class=\"type\">Array</span>(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stride</span>(from: <span class=\"number\">0</span>, to: <span class=\"built_in\">count</span>, by: <span class=\"number\">2</span>).compactMap &#123; <span class=\"type\">UInt8</span>(<span class=\"type\">String</span>(hexa[$<span class=\"number\">0</span>..&lt;$<span class=\"number\">0</span>.advanced(by: <span class=\"number\">2</span>)]), radix: <span class=\"number\">16</span>) &#125;</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"获取UICollectionView显示的中间的Cell\"><a href=\"#获取UICollectionView显示的中间的Cell\" class=\"headerlink\" title=\"获取UICollectionView显示的中间的Cell\"></a>获取UICollectionView显示的中间的Cell</h5><p>遵守Scrollview的代理方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scrollViewDidEndDecelerating</span><span class=\"params\">(<span class=\"number\">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">let</span> centerCellIndexPath = dateCollectView!.getMidVisibleIndexPath()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">let</span>  horDateSelectorCollectionViewCell = dateCollectView!.cellForItem(at: centerCellIndexPath!) <span class=\"keyword\">as</span>? <span class=\"type\">FDHorDateSelectorCollectionViewCell</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对UICollectionViewCell的extension</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">CollectionVisibleMidCell</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">CollectionVisibleMidCell</span> <span class=\"title\">where</span> <span class=\"title\">Self</span>: <span class=\"title\">UICollectionView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getMidVisibleIndexPath</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">IndexPath?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> visibleRect = <span class=\"type\">CGRect</span>()</span><br><span class=\"line\">        visibleRect.origin = <span class=\"keyword\">self</span>.contentOffset</span><br><span class=\"line\">        visibleRect.size = <span class=\"keyword\">self</span>.bounds.size</span><br><span class=\"line\">        <span class=\"keyword\">let</span> visiblePoint = <span class=\"type\">CGPoint</span>(x: visibleRect.midX, y: visibleRect.midY)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> indexPath = <span class=\"keyword\">self</span>.indexPathForItem(at: visiblePoint) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexPath</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UICollectionView</span>: <span class=\"title\">CollectionVisibleMidCell</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"OC\"><a href=\"#OC\" class=\"headerlink\" title=\"OC\"></a>OC</h1>","site":{"data":{}},"excerpt":"<h1 id=\"Swift\"><a href=\"#Swift\" class=\"headerlink\" title=\"Swift\"></a>Swift</h1><h5 id=\"对象数据转字典\"><a href=\"#对象数据转字典\" class=\"headerlink\" title=\"对象数据转字典\"></a>对象数据转字典</h5><p>通讯录中<code>UITableView</code>的数据源.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"type\">ContactsModel</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> res = <span class=\"type\">Dictionary</span>(grouping: arr, by: &#123; $<span class=\"number\">0</span>.name.<span class=\"keyword\">prefix</span>(<span class=\"number\">1</span>).uppercased()&#125;) <span class=\"comment\">// [String:[ContactsModel]]</span></span><br></pre></td></tr></table></figure>","more":"<h5 id=\"汉字转拼音\"><a href=\"#汉字转拼音\" class=\"headerlink\" title=\"汉字转拼音\"></a>汉字转拼音</h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transformToPinYin</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> mutableString = <span class=\"type\">NSMutableString</span>(string: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformToLatin, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"type\">CFStringTransform</span>(mutableString, <span class=\"literal\">nil</span>, kCFStringTransformStripDiacritics, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> string = <span class=\"type\">String</span>(mutableString)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> string.replacingOccurrences(of: <span class=\"string\">\" \"</span>, with: <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Hex-to-byte\"><a href=\"#Hex-to-byte\" class=\"headerlink\" title=\"Hex to byte\"></a>Hex to byte</h5><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">StringProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hexa2Bytes: [<span class=\"type\">UInt8</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> hexa = <span class=\"type\">Array</span>(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stride</span>(from: <span class=\"number\">0</span>, to: <span class=\"built_in\">count</span>, by: <span class=\"number\">2</span>).compactMap &#123; <span class=\"type\">UInt8</span>(<span class=\"type\">String</span>(hexa[$<span class=\"number\">0</span>..&lt;$<span class=\"number\">0</span>.advanced(by: <span class=\"number\">2</span>)]), radix: <span class=\"number\">16</span>) &#125;</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"获取UICollectionView显示的中间的Cell\"><a href=\"#获取UICollectionView显示的中间的Cell\" class=\"headerlink\" title=\"获取UICollectionView显示的中间的Cell\"></a>获取UICollectionView显示的中间的Cell</h5><p>遵守Scrollview的代理方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scrollViewDidEndDecelerating</span><span class=\"params\">(<span class=\"number\">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">let</span> centerCellIndexPath = dateCollectView!.getMidVisibleIndexPath()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">let</span>  horDateSelectorCollectionViewCell = dateCollectView!.cellForItem(at: centerCellIndexPath!) <span class=\"keyword\">as</span>? <span class=\"type\">FDHorDateSelectorCollectionViewCell</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对UICollectionViewCell的extension</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">CollectionVisibleMidCell</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">CollectionVisibleMidCell</span> <span class=\"title\">where</span> <span class=\"title\">Self</span>: <span class=\"title\">UICollectionView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getMidVisibleIndexPath</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">IndexPath?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> visibleRect = <span class=\"type\">CGRect</span>()</span><br><span class=\"line\">        visibleRect.origin = <span class=\"keyword\">self</span>.contentOffset</span><br><span class=\"line\">        visibleRect.size = <span class=\"keyword\">self</span>.bounds.size</span><br><span class=\"line\">        <span class=\"keyword\">let</span> visiblePoint = <span class=\"type\">CGPoint</span>(x: visibleRect.midX, y: visibleRect.midY)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> indexPath = <span class=\"keyword\">self</span>.indexPathForItem(at: visiblePoint) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexPath</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UICollectionView</span>: <span class=\"title\">CollectionVisibleMidCell</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"OC\"><a href=\"#OC\" class=\"headerlink\" title=\"OC\"></a>OC</h1>"},{"title":"重置Mac管理员名称和密码","date":"2019-09-23T02:55:53.000Z","_content":"\n# 问题\n\n使用mac系统，忘记了管理员名称或密码。\n\n<!-- more -->\n\n# 解决方法\n\n1. 将电脑关机。\n\n2. 按住 `command + s`，并按下开机键。\n\n3. 屏幕进度条跑完，会自动执行指令等待执行完成。\n\n4. 在光标处键入` /sbin/mount -uaw `，回车。等待命令执行完成。\n\n5. 在光标处键入`rm var/db/.applesetupdone `，回车。等待命令执行完成。\n\n6. 在光标处键入`reboot  `，回车。页面跳转。\n\n7. 按照系统给出的步骤，重置管理员名称和密码。\n\n   ![步骤](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/ReSetAdministratorNameAndPS/1-1.png)\n\n\n\n# 总结\n\n1. 该是重置管理名称和密码，也是相当于新建了一个mac账号，该账号是管理员账号。\n\n2. 经测试，当前不是管理管理员账户时，该操作不会删除任何东西。\n\n   ","source":"_posts/重置Mac管理员名称和密码.md","raw":"---\ntitle: 重置Mac管理员名称和密码\ndate: 2019-09-23 10:55:53\ntags: 软件、工具的使用\n---\n\n# 问题\n\n使用mac系统，忘记了管理员名称或密码。\n\n<!-- more -->\n\n# 解决方法\n\n1. 将电脑关机。\n\n2. 按住 `command + s`，并按下开机键。\n\n3. 屏幕进度条跑完，会自动执行指令等待执行完成。\n\n4. 在光标处键入` /sbin/mount -uaw `，回车。等待命令执行完成。\n\n5. 在光标处键入`rm var/db/.applesetupdone `，回车。等待命令执行完成。\n\n6. 在光标处键入`reboot  `，回车。页面跳转。\n\n7. 按照系统给出的步骤，重置管理员名称和密码。\n\n   ![步骤](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/ReSetAdministratorNameAndPS/1-1.png)\n\n\n\n# 总结\n\n1. 该是重置管理名称和密码，也是相当于新建了一个mac账号，该账号是管理员账号。\n\n2. 经测试，当前不是管理管理员账户时，该操作不会删除任何东西。\n\n   ","slug":"重置Mac管理员名称和密码","published":1,"updated":"2019-09-23T07:12:25.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke16l0007bfgaveg60xdy","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>使用mac系统，忘记了管理员名称或密码。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><ol>\n<li><p>将电脑关机。</p>\n</li>\n<li><p>按住 <code>command + s</code>，并按下开机键。</p>\n</li>\n<li><p>屏幕进度条跑完，会自动执行指令等待执行完成。</p>\n</li>\n<li><p>在光标处键入<code>/sbin/mount -uaw</code>，回车。等待命令执行完成。</p>\n</li>\n<li><p>在光标处键入<code>rm var/db/.applesetupdone</code>，回车。等待命令执行完成。</p>\n</li>\n<li><p>在光标处键入<code>reboot</code>，回车。页面跳转。</p>\n</li>\n<li><p>按照系统给出的步骤，重置管理员名称和密码。</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/ReSetAdministratorNameAndPS/1-1.png\" alt=\"步骤\"></p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li><p>该是重置管理名称和密码，也是相当于新建了一个mac账号，该账号是管理员账号。</p>\n</li>\n<li><p>经测试，当前不是管理管理员账户时，该操作不会删除任何东西。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>使用mac系统，忘记了管理员名称或密码。</p>","more":"<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><ol>\n<li><p>将电脑关机。</p>\n</li>\n<li><p>按住 <code>command + s</code>，并按下开机键。</p>\n</li>\n<li><p>屏幕进度条跑完，会自动执行指令等待执行完成。</p>\n</li>\n<li><p>在光标处键入<code>/sbin/mount -uaw</code>，回车。等待命令执行完成。</p>\n</li>\n<li><p>在光标处键入<code>rm var/db/.applesetupdone</code>，回车。等待命令执行完成。</p>\n</li>\n<li><p>在光标处键入<code>reboot</code>，回车。页面跳转。</p>\n</li>\n<li><p>按照系统给出的步骤，重置管理员名称和密码。</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/ReSetAdministratorNameAndPS/1-1.png\" alt=\"步骤\"></p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li><p>该是重置管理名称和密码，也是相当于新建了一个mac账号，该账号是管理员账号。</p>\n</li>\n<li><p>经测试，当前不是管理管理员账户时，该操作不会删除任何东西。</p>\n</li>\n</ol>"},{"title":"SwiftLint的使用","date":"2019-09-10T08:05:01.000Z","_content":"\n# 简介\n\n- 为了促进 iOS 项目小组各成员之间高效的合作。 使整个软件开发工作可以协调有序地进行。 iOS项目采用 Swift 语言开发时，项目可以使用 SwiftLint 第三方工具规范代码风格。\n- [SwiftLint](https://github.com/realm/SwiftLint)是 [Realm](https://realm.io/) 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 [Github 公布的 Swift 代码规范](https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md)进行代码检查。\n<!-- more -->\n\n# 安装\n\n## 使用 Homebrew 安装\n\n全局安装，一次安装，所有项目可用。\n\n- 在终端输入以前命令进行安装：`brew install swiftlint`\n\n![屏幕快照 2019-09-10 14.41.28](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-2.png)\n\n- 验证安装成功: `swiftlint help`\n\n![屏幕快照 2019-09-10 14.42.07](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-3.png)\n\n\n\n## 使用Cocoapods安装\n\n- 在Podfile文件中添加如下代码：`pod 'SwiftLint' `\n- cd到项目根目录下： `Pod install`\n- 安装成后打开 XX.xcworkspace 文件即可。\n\n\n\n# 用法\n\n在Xcode中写入Shell脚本\n\n![RUNOOB 图片](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-1.png \"位置指引\")\n\n1. 使用Homebrew安装后要执行脚本代码：\n\n```shell\nif which swiftlint >/dev/null; then\nswiftlint\nelse\necho \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"\nfi\n```\n\n\n\n2. 使用Cocoapods安装后要执行的脚本代码\n\n```shell\n\"${PODS_ROOT}/SwiftLint/swiftlint\"\n```\n\n# 配置\n\n## 创建配置文件\n\ncd到项目根目录下,  在终端输入： `touch .swiftlint.yml` 创建配置文件。执行完该命令后,  在文件夹中可能找不到该yml格式文件, 那是因为文件被隐藏了。使用 command + shift + . 显示（隐藏）文件。\n\n```tex\ndisabled_rules: # 执行时排除掉的规则\n- colon #冒号\n- comma #逗号\n- control_statement #控制声明\nopt_in_rules: # 一些规则仅仅是可选的\n- empty_count\n- missing_docs\n# 可以通过执行如下指令来查找所有可用的规则:\n# swiftlint rules\nincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。\n- Source # 要确保项目中有这个文件夹\nexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。\n- Carthage\n- Pods\n- Source/ExcludedFolder\n- Source/ExcludedFile.swift\n\n# 可配置的规则可以通过这个配置文件来自定义\n# 二进制规则可以设置他们的严格程度\nforce_cast: warning # 隐式\nforce_try:\nseverity: warning # 显式\n# 同时有警告和错误等级的规则，可以只设置它的警告等级\n# 隐式\nline_length: 110\n# 可以通过一个数组同时进行隐式设置\ntype_body_length:\n- 300 # warning\n- 400 # error\n# 或者也可以同时进行显式设置\nfile_length:\nwarning: 500\nerror: 1200\n# 命名规则可以设置最小长度和最大程度的警告/错误\n# 此外它们也可以设置排除在外的名字\ntype_name:\nmin_length: 4 # 只是警告\nmax_length: # 警告和错误\nwarning: 40\nerror: 50\nexcluded: iPhone # 排除某个名字\nidentifier_name:\nmin_length: # 只有最小长度\nerror: 4 # 只有错误\nexcluded: # 排除某些名字\n- id\n- URL\n- GlobalAPIKey\nreporter: \"xcode\" # 报告类型 (xcode, json, csv, checkstyle, junit, html, emoji)\n\n```\n\n这是官方给出的配置。把它复制到项目的配置文件中，可能会报如下错误：\n\n![屏幕快照 2019-09-10 15.15.13](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-4.png)\n\n报错原因是：项目中不存在Source文件夹，在配置文件中删除- Source再command + b就不会有错误了。\n\n## 在代码中关闭某个规则\n\n- 可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：\n\n`// swiftlint:disable <rule>`\n\n在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：\n\n`// swiftlint:enable <rule>`\n\n例如新建项目AppDelegate中默认的方法名长度都超过SwiftLint官方给出的方法长度。\n\n```swift\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n// Override point for customization after application launch.\nreturn true\n}\n```\n\n对这部分代码关闭长度限制前提示：行数不应超过110个字符：当前为145个字符（line_length）\n\n![屏幕快照 2019-09-10 15.34.05](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-5.png)\n\n对这部分代码关闭长度限制后无提示\n\n![屏幕快照 2019-09-10 15.35.15](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-6.png)\n\n- 若要对文件中关闭所有的规则，可使用以下代码对：\n\n  `// swiftlint:disable all`\n\n  `// swiftlint:enable all`\n\n- 可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。\n\n```swift\n// swiftlint:disable:next force_cast\nlet noWarning = NSNumber() as! Int\nlet hasWarning = NSNumber() as! Int\nlet noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_cast\nlet noWarning3 = NSNumber() as! Int\n// swiftlint:disable:previous force_cast\n```\n\n## 忽略引入的第三方库\n\n- 忽略CocoaPods导入的第三方库，excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹,比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表：\n\n```\nexcluded:\n- Pods\n- Carthage\n```\n\n- 指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了\n\n```excluded:\nexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。\n- Source/ExcludedFolder\n- Source/ExcludedFile.swift\n```\n\n# 自动更正（慎用）\n\n`SwiftLint`可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。\n\n确保在对文件执行 `swiftlint autocorrect`之前有对它们做过备份，否则的话有可能导致重要数据的丢失。\n\n因为在执行自动更正只是更正代码规则，无法检测逻辑，在更正的时候会有可能代码逻辑，带来更多问题 ！\n\n# 其他\n\n经测试，当项目中有OC代码时，SwiftLint对其无约束规范的提示。","source":"_posts/SwiftLint的使用.md","raw":"---\ntitle: SwiftLint的使用\ndate: 2019-09-10 16:05:01\ntags: 第三方的使用\n---\n\n# 简介\n\n- 为了促进 iOS 项目小组各成员之间高效的合作。 使整个软件开发工作可以协调有序地进行。 iOS项目采用 Swift 语言开发时，项目可以使用 SwiftLint 第三方工具规范代码风格。\n- [SwiftLint](https://github.com/realm/SwiftLint)是 [Realm](https://realm.io/) 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 [Github 公布的 Swift 代码规范](https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md)进行代码检查。\n<!-- more -->\n\n# 安装\n\n## 使用 Homebrew 安装\n\n全局安装，一次安装，所有项目可用。\n\n- 在终端输入以前命令进行安装：`brew install swiftlint`\n\n![屏幕快照 2019-09-10 14.41.28](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-2.png)\n\n- 验证安装成功: `swiftlint help`\n\n![屏幕快照 2019-09-10 14.42.07](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-3.png)\n\n\n\n## 使用Cocoapods安装\n\n- 在Podfile文件中添加如下代码：`pod 'SwiftLint' `\n- cd到项目根目录下： `Pod install`\n- 安装成后打开 XX.xcworkspace 文件即可。\n\n\n\n# 用法\n\n在Xcode中写入Shell脚本\n\n![RUNOOB 图片](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-1.png \"位置指引\")\n\n1. 使用Homebrew安装后要执行脚本代码：\n\n```shell\nif which swiftlint >/dev/null; then\nswiftlint\nelse\necho \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"\nfi\n```\n\n\n\n2. 使用Cocoapods安装后要执行的脚本代码\n\n```shell\n\"${PODS_ROOT}/SwiftLint/swiftlint\"\n```\n\n# 配置\n\n## 创建配置文件\n\ncd到项目根目录下,  在终端输入： `touch .swiftlint.yml` 创建配置文件。执行完该命令后,  在文件夹中可能找不到该yml格式文件, 那是因为文件被隐藏了。使用 command + shift + . 显示（隐藏）文件。\n\n```tex\ndisabled_rules: # 执行时排除掉的规则\n- colon #冒号\n- comma #逗号\n- control_statement #控制声明\nopt_in_rules: # 一些规则仅仅是可选的\n- empty_count\n- missing_docs\n# 可以通过执行如下指令来查找所有可用的规则:\n# swiftlint rules\nincluded: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。\n- Source # 要确保项目中有这个文件夹\nexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。\n- Carthage\n- Pods\n- Source/ExcludedFolder\n- Source/ExcludedFile.swift\n\n# 可配置的规则可以通过这个配置文件来自定义\n# 二进制规则可以设置他们的严格程度\nforce_cast: warning # 隐式\nforce_try:\nseverity: warning # 显式\n# 同时有警告和错误等级的规则，可以只设置它的警告等级\n# 隐式\nline_length: 110\n# 可以通过一个数组同时进行隐式设置\ntype_body_length:\n- 300 # warning\n- 400 # error\n# 或者也可以同时进行显式设置\nfile_length:\nwarning: 500\nerror: 1200\n# 命名规则可以设置最小长度和最大程度的警告/错误\n# 此外它们也可以设置排除在外的名字\ntype_name:\nmin_length: 4 # 只是警告\nmax_length: # 警告和错误\nwarning: 40\nerror: 50\nexcluded: iPhone # 排除某个名字\nidentifier_name:\nmin_length: # 只有最小长度\nerror: 4 # 只有错误\nexcluded: # 排除某些名字\n- id\n- URL\n- GlobalAPIKey\nreporter: \"xcode\" # 报告类型 (xcode, json, csv, checkstyle, junit, html, emoji)\n\n```\n\n这是官方给出的配置。把它复制到项目的配置文件中，可能会报如下错误：\n\n![屏幕快照 2019-09-10 15.15.13](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-4.png)\n\n报错原因是：项目中不存在Source文件夹，在配置文件中删除- Source再command + b就不会有错误了。\n\n## 在代码中关闭某个规则\n\n- 可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：\n\n`// swiftlint:disable <rule>`\n\n在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：\n\n`// swiftlint:enable <rule>`\n\n例如新建项目AppDelegate中默认的方法名长度都超过SwiftLint官方给出的方法长度。\n\n```swift\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n// Override point for customization after application launch.\nreturn true\n}\n```\n\n对这部分代码关闭长度限制前提示：行数不应超过110个字符：当前为145个字符（line_length）\n\n![屏幕快照 2019-09-10 15.34.05](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-5.png)\n\n对这部分代码关闭长度限制后无提示\n\n![屏幕快照 2019-09-10 15.35.15](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-6.png)\n\n- 若要对文件中关闭所有的规则，可使用以下代码对：\n\n  `// swiftlint:disable all`\n\n  `// swiftlint:enable all`\n\n- 可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。\n\n```swift\n// swiftlint:disable:next force_cast\nlet noWarning = NSNumber() as! Int\nlet hasWarning = NSNumber() as! Int\nlet noWarning2 = NSNumber() as! Int // swiftlint:disable:this force_cast\nlet noWarning3 = NSNumber() as! Int\n// swiftlint:disable:previous force_cast\n```\n\n## 忽略引入的第三方库\n\n- 忽略CocoaPods导入的第三方库，excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹,比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表：\n\n```\nexcluded:\n- Pods\n- Carthage\n```\n\n- 指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了\n\n```excluded:\nexcluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。\n- Source/ExcludedFolder\n- Source/ExcludedFile.swift\n```\n\n# 自动更正（慎用）\n\n`SwiftLint`可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。\n\n确保在对文件执行 `swiftlint autocorrect`之前有对它们做过备份，否则的话有可能导致重要数据的丢失。\n\n因为在执行自动更正只是更正代码规则，无法检测逻辑，在更正的时候会有可能代码逻辑，带来更多问题 ！\n\n# 其他\n\n经测试，当项目中有OC代码时，SwiftLint对其无约束规范的提示。","slug":"SwiftLint的使用","published":1,"updated":"2019-09-11T03:41:33.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke18g000abfgakz6q5fo9","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li>为了促进 iOS 项目小组各成员之间高效的合作。 使整个软件开发工作可以协调有序地进行。 iOS项目采用 Swift 语言开发时，项目可以使用 SwiftLint 第三方工具规范代码风格。</li>\n<li><a href=\"https://github.com/realm/SwiftLint\" target=\"_blank\" rel=\"noopener\">SwiftLint</a>是 <a href=\"https://realm.io/\" target=\"_blank\" rel=\"noopener\">Realm</a> 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 <a href=\"https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md\" target=\"_blank\" rel=\"noopener\">Github 公布的 Swift 代码规范</a>进行代码检查。<a id=\"more\"></a>\n\n</li>\n</ul>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"使用-Homebrew-安装\"><a href=\"#使用-Homebrew-安装\" class=\"headerlink\" title=\"使用 Homebrew 安装\"></a>使用 Homebrew 安装</h2><p>全局安装，一次安装，所有项目可用。</p>\n<ul>\n<li>在终端输入以前命令进行安装：<code>brew install swiftlint</code></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-2.png\" alt=\"屏幕快照 2019-09-10 14.41.28\"></p>\n<ul>\n<li>验证安装成功: <code>swiftlint help</code></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-3.png\" alt=\"屏幕快照 2019-09-10 14.42.07\"></p>\n<h2 id=\"使用Cocoapods安装\"><a href=\"#使用Cocoapods安装\" class=\"headerlink\" title=\"使用Cocoapods安装\"></a>使用Cocoapods安装</h2><ul>\n<li>在Podfile文件中添加如下代码：<code>pod &#39;SwiftLint&#39;</code></li>\n<li>cd到项目根目录下： <code>Pod install</code></li>\n<li>安装成后打开 XX.xcworkspace 文件即可。</li>\n</ul>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>在Xcode中写入Shell脚本</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-1.png\" alt=\"RUNOOB 图片\" title=\"位置指引\"></p>\n<ol>\n<li>使用Homebrew安装后要执行脚本代码：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if which swiftlint &gt;/dev/null; then</span><br><span class=\"line\">swiftlint</span><br><span class=\"line\">else</span><br><span class=\"line\">echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用Cocoapods安装后要执行的脚本代码</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint\"</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"创建配置文件\"><a href=\"#创建配置文件\" class=\"headerlink\" title=\"创建配置文件\"></a>创建配置文件</h2><p>cd到项目根目录下,  在终端输入： <code>touch .swiftlint.yml</code> 创建配置文件。执行完该命令后,  在文件夹中可能找不到该yml格式文件, 那是因为文件被隐藏了。使用 command + shift + . 显示（隐藏）文件。</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disabled_rules: # 执行时排除掉的规则</span><br><span class=\"line\">- colon #冒号</span><br><span class=\"line\">- comma #逗号</span><br><span class=\"line\">- control_statement #控制声明</span><br><span class=\"line\">opt_in_rules: # 一些规则仅仅是可选的</span><br><span class=\"line\">- empty_count</span><br><span class=\"line\">- missing_docs</span><br><span class=\"line\"># 可以通过执行如下指令来查找所有可用的规则:</span><br><span class=\"line\"># swiftlint rules</span><br><span class=\"line\">included: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。</span><br><span class=\"line\">- Source # 要确保项目中有这个文件夹</span><br><span class=\"line\">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class=\"line\">- Carthage</span><br><span class=\"line\">- Pods</span><br><span class=\"line\">- Source/ExcludedFolder</span><br><span class=\"line\">- Source/ExcludedFile.swift</span><br><span class=\"line\"></span><br><span class=\"line\"># 可配置的规则可以通过这个配置文件来自定义</span><br><span class=\"line\"># 二进制规则可以设置他们的严格程度</span><br><span class=\"line\">force_cast: warning # 隐式</span><br><span class=\"line\">force_try:</span><br><span class=\"line\">severity: warning # 显式</span><br><span class=\"line\"># 同时有警告和错误等级的规则，可以只设置它的警告等级</span><br><span class=\"line\"># 隐式</span><br><span class=\"line\">line_length: 110</span><br><span class=\"line\"># 可以通过一个数组同时进行隐式设置</span><br><span class=\"line\">type_body_length:</span><br><span class=\"line\">- 300 # warning</span><br><span class=\"line\">- 400 # error</span><br><span class=\"line\"># 或者也可以同时进行显式设置</span><br><span class=\"line\">file_length:</span><br><span class=\"line\">warning: 500</span><br><span class=\"line\">error: 1200</span><br><span class=\"line\"># 命名规则可以设置最小长度和最大程度的警告/错误</span><br><span class=\"line\"># 此外它们也可以设置排除在外的名字</span><br><span class=\"line\">type_name:</span><br><span class=\"line\">min_length: 4 # 只是警告</span><br><span class=\"line\">max_length: # 警告和错误</span><br><span class=\"line\">warning: 40</span><br><span class=\"line\">error: 50</span><br><span class=\"line\">excluded: iPhone # 排除某个名字</span><br><span class=\"line\">identifier_name:</span><br><span class=\"line\">min_length: # 只有最小长度</span><br><span class=\"line\">error: 4 # 只有错误</span><br><span class=\"line\">excluded: # 排除某些名字</span><br><span class=\"line\">- id</span><br><span class=\"line\">- URL</span><br><span class=\"line\">- GlobalAPIKey</span><br><span class=\"line\">reporter: \"xcode\" # 报告类型 (xcode, json, csv, checkstyle, junit, html, emoji)</span><br></pre></td></tr></table></figure>\n\n<p>这是官方给出的配置。把它复制到项目的配置文件中，可能会报如下错误：</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-4.png\" alt=\"屏幕快照 2019-09-10 15.15.13\"></p>\n<p>报错原因是：项目中不存在Source文件夹，在配置文件中删除- Source再command + b就不会有错误了。</p>\n<h2 id=\"在代码中关闭某个规则\"><a href=\"#在代码中关闭某个规则\" class=\"headerlink\" title=\"在代码中关闭某个规则\"></a>在代码中关闭某个规则</h2><ul>\n<li>可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：</li>\n</ul>\n<p><code>// swiftlint:disable &lt;rule&gt;</code></p>\n<p>在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：</p>\n<p><code>// swiftlint:enable &lt;rule&gt;</code></p>\n<p>例如新建项目AppDelegate中默认的方法名长度都超过SwiftLint官方给出的方法长度。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class=\"keyword\">Any</span>]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对这部分代码关闭长度限制前提示：行数不应超过110个字符：当前为145个字符（line_length）</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-5.png\" alt=\"屏幕快照 2019-09-10 15.34.05\"></p>\n<p>对这部分代码关闭长度限制后无提示</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-6.png\" alt=\"屏幕快照 2019-09-10 15.35.15\"></p>\n<ul>\n<li><p>若要对文件中关闭所有的规则，可使用以下代码对：</p>\n<p><code>// swiftlint:disable all</code></p>\n<p><code>// swiftlint:enable all</code></p>\n</li>\n<li><p>可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。</p>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swiftlint:disable:next force_cast</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> noWarning = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hasWarning = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> noWarning2 = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span> <span class=\"comment\">// swiftlint:disable:this force_cast</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> noWarning3 = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">// swiftlint:disable:previous force_cast</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"忽略引入的第三方库\"><a href=\"#忽略引入的第三方库\" class=\"headerlink\" title=\"忽略引入的第三方库\"></a>忽略引入的第三方库</h2><ul>\n<li>忽略CocoaPods导入的第三方库，excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹,比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">excluded:</span><br><span class=\"line\">- Pods</span><br><span class=\"line\">- Carthage</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class=\"line\">- Source/ExcludedFolder</span><br><span class=\"line\">- Source/ExcludedFile.swift</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自动更正（慎用）\"><a href=\"#自动更正（慎用）\" class=\"headerlink\" title=\"自动更正（慎用）\"></a>自动更正（慎用）</h1><p><code>SwiftLint</code>可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。</p>\n<p>确保在对文件执行 <code>swiftlint autocorrect</code>之前有对它们做过备份，否则的话有可能导致重要数据的丢失。</p>\n<p>因为在执行自动更正只是更正代码规则，无法检测逻辑，在更正的时候会有可能代码逻辑，带来更多问题 ！</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>经测试，当项目中有OC代码时，SwiftLint对其无约束规范的提示。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li>为了促进 iOS 项目小组各成员之间高效的合作。 使整个软件开发工作可以协调有序地进行。 iOS项目采用 Swift 语言开发时，项目可以使用 SwiftLint 第三方工具规范代码风格。</li>\n<li><a href=\"https://github.com/realm/SwiftLint\" target=\"_blank\" rel=\"noopener\">SwiftLint</a>是 <a href=\"https://realm.io/\" target=\"_blank\" rel=\"noopener\">Realm</a> 推出的一款 Swift 代码规范检查工具, SwiftLint 基于 <a href=\"https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md\" target=\"_blank\" rel=\"noopener\">Github 公布的 Swift 代码规范</a>进行代码检查。","more":"</li>\n</ul>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"使用-Homebrew-安装\"><a href=\"#使用-Homebrew-安装\" class=\"headerlink\" title=\"使用 Homebrew 安装\"></a>使用 Homebrew 安装</h2><p>全局安装，一次安装，所有项目可用。</p>\n<ul>\n<li>在终端输入以前命令进行安装：<code>brew install swiftlint</code></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-2.png\" alt=\"屏幕快照 2019-09-10 14.41.28\"></p>\n<ul>\n<li>验证安装成功: <code>swiftlint help</code></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-3.png\" alt=\"屏幕快照 2019-09-10 14.42.07\"></p>\n<h2 id=\"使用Cocoapods安装\"><a href=\"#使用Cocoapods安装\" class=\"headerlink\" title=\"使用Cocoapods安装\"></a>使用Cocoapods安装</h2><ul>\n<li>在Podfile文件中添加如下代码：<code>pod &#39;SwiftLint&#39;</code></li>\n<li>cd到项目根目录下： <code>Pod install</code></li>\n<li>安装成后打开 XX.xcworkspace 文件即可。</li>\n</ul>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>在Xcode中写入Shell脚本</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-1.png\" alt=\"RUNOOB 图片\" title=\"位置指引\"></p>\n<ol>\n<li>使用Homebrew安装后要执行脚本代码：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if which swiftlint &gt;/dev/null; then</span><br><span class=\"line\">swiftlint</span><br><span class=\"line\">else</span><br><span class=\"line\">echo \"warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用Cocoapods安装后要执行的脚本代码</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint\"</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"创建配置文件\"><a href=\"#创建配置文件\" class=\"headerlink\" title=\"创建配置文件\"></a>创建配置文件</h2><p>cd到项目根目录下,  在终端输入： <code>touch .swiftlint.yml</code> 创建配置文件。执行完该命令后,  在文件夹中可能找不到该yml格式文件, 那是因为文件被隐藏了。使用 command + shift + . 显示（隐藏）文件。</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disabled_rules: # 执行时排除掉的规则</span><br><span class=\"line\">- colon #冒号</span><br><span class=\"line\">- comma #逗号</span><br><span class=\"line\">- control_statement #控制声明</span><br><span class=\"line\">opt_in_rules: # 一些规则仅仅是可选的</span><br><span class=\"line\">- empty_count</span><br><span class=\"line\">- missing_docs</span><br><span class=\"line\"># 可以通过执行如下指令来查找所有可用的规则:</span><br><span class=\"line\"># swiftlint rules</span><br><span class=\"line\">included: # 执行 linting 时包含的路径。如果出现这个 `--path` 会被忽略。</span><br><span class=\"line\">- Source # 要确保项目中有这个文件夹</span><br><span class=\"line\">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class=\"line\">- Carthage</span><br><span class=\"line\">- Pods</span><br><span class=\"line\">- Source/ExcludedFolder</span><br><span class=\"line\">- Source/ExcludedFile.swift</span><br><span class=\"line\"></span><br><span class=\"line\"># 可配置的规则可以通过这个配置文件来自定义</span><br><span class=\"line\"># 二进制规则可以设置他们的严格程度</span><br><span class=\"line\">force_cast: warning # 隐式</span><br><span class=\"line\">force_try:</span><br><span class=\"line\">severity: warning # 显式</span><br><span class=\"line\"># 同时有警告和错误等级的规则，可以只设置它的警告等级</span><br><span class=\"line\"># 隐式</span><br><span class=\"line\">line_length: 110</span><br><span class=\"line\"># 可以通过一个数组同时进行隐式设置</span><br><span class=\"line\">type_body_length:</span><br><span class=\"line\">- 300 # warning</span><br><span class=\"line\">- 400 # error</span><br><span class=\"line\"># 或者也可以同时进行显式设置</span><br><span class=\"line\">file_length:</span><br><span class=\"line\">warning: 500</span><br><span class=\"line\">error: 1200</span><br><span class=\"line\"># 命名规则可以设置最小长度和最大程度的警告/错误</span><br><span class=\"line\"># 此外它们也可以设置排除在外的名字</span><br><span class=\"line\">type_name:</span><br><span class=\"line\">min_length: 4 # 只是警告</span><br><span class=\"line\">max_length: # 警告和错误</span><br><span class=\"line\">warning: 40</span><br><span class=\"line\">error: 50</span><br><span class=\"line\">excluded: iPhone # 排除某个名字</span><br><span class=\"line\">identifier_name:</span><br><span class=\"line\">min_length: # 只有最小长度</span><br><span class=\"line\">error: 4 # 只有错误</span><br><span class=\"line\">excluded: # 排除某些名字</span><br><span class=\"line\">- id</span><br><span class=\"line\">- URL</span><br><span class=\"line\">- GlobalAPIKey</span><br><span class=\"line\">reporter: \"xcode\" # 报告类型 (xcode, json, csv, checkstyle, junit, html, emoji)</span><br></pre></td></tr></table></figure>\n\n<p>这是官方给出的配置。把它复制到项目的配置文件中，可能会报如下错误：</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-4.png\" alt=\"屏幕快照 2019-09-10 15.15.13\"></p>\n<p>报错原因是：项目中不存在Source文件夹，在配置文件中删除- Source再command + b就不会有错误了。</p>\n<h2 id=\"在代码中关闭某个规则\"><a href=\"#在代码中关闭某个规则\" class=\"headerlink\" title=\"在代码中关闭某个规则\"></a>在代码中关闭某个规则</h2><ul>\n<li>可以通过在一个源文件中定义一个如下格式的注释来关闭某个规则：</li>\n</ul>\n<p><code>// swiftlint:disable &lt;rule&gt;</code></p>\n<p>在该文件结束之前或者在定义如下格式的匹配注释之前，这条规则都会被禁用：</p>\n<p><code>// swiftlint:enable &lt;rule&gt;</code></p>\n<p>例如新建项目AppDelegate中默认的方法名长度都超过SwiftLint官方给出的方法长度。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class=\"keyword\">Any</span>]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// Override point for customization after application launch.</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对这部分代码关闭长度限制前提示：行数不应超过110个字符：当前为145个字符（line_length）</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-5.png\" alt=\"屏幕快照 2019-09-10 15.34.05\"></p>\n<p>对这部分代码关闭长度限制后无提示</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUserSwiftLint/1-6.png\" alt=\"屏幕快照 2019-09-10 15.35.15\"></p>\n<ul>\n<li><p>若要对文件中关闭所有的规则，可使用以下代码对：</p>\n<p><code>// swiftlint:disable all</code></p>\n<p><code>// swiftlint:enable all</code></p>\n</li>\n<li><p>可以通过添加 :previous, :this 或者 :next 来使关闭或者打开某条规则的命令分别应用于前一行，当前或者后一行代码。</p>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swiftlint:disable:next force_cast</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> noWarning = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hasWarning = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> noWarning2 = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span> <span class=\"comment\">// swiftlint:disable:this force_cast</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> noWarning3 = <span class=\"type\">NSNumber</span>() <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></span><br><span class=\"line\"><span class=\"comment\">// swiftlint:disable:previous force_cast</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"忽略引入的第三方库\"><a href=\"#忽略引入的第三方库\" class=\"headerlink\" title=\"忽略引入的第三方库\"></a>忽略引入的第三方库</h2><ul>\n<li>忽略CocoaPods导入的第三方库，excluded 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹,比如如果你的项目使用 Carthage 管理第三方库的话，可以将 Carthage 目录添加到忽略列表：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">excluded:</span><br><span class=\"line\">- Pods</span><br><span class=\"line\">- Carthage</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定精确路径下的文件，通过 - xxxx 的形式列在下面就可以了</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">excluded: # 执行 linting 时忽略的路径。 优先级比 `included` 更高。</span><br><span class=\"line\">- Source/ExcludedFolder</span><br><span class=\"line\">- Source/ExcludedFile.swift</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自动更正（慎用）\"><a href=\"#自动更正（慎用）\" class=\"headerlink\" title=\"自动更正（慎用）\"></a>自动更正（慎用）</h1><p><code>SwiftLint</code>可以自动修正某些错误，磁盘上的文件会被一个修正后的版本覆盖。</p>\n<p>确保在对文件执行 <code>swiftlint autocorrect</code>之前有对它们做过备份，否则的话有可能导致重要数据的丢失。</p>\n<p>因为在执行自动更正只是更正代码规则，无法检测逻辑，在更正的时候会有可能代码逻辑，带来更多问题 ！</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>经测试，当项目中有OC代码时，SwiftLint对其无约束规范的提示。</p>"},{"title":"Nmap的简单使用","date":"2019-09-26T12:55:23.000Z","_content":"\n\n\n# 安装\n\n## 客户端安装\n\n### 打开官网链接\n\n<!-- more -->\n\n[官网地址](https://nmap.org/download.html)\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-1.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-1 官网下载Mac版地址\n\n### 下载客户端，安装完成\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-2.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-2 客户端终端图标\n\n## 终端安装\n\n命令：`brew install nmap`\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-3.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-3 安装完成后再次安装后的终端输出\n\n#  使用\n\n## 在终端的使用 \n\n### 扫描主机所有端口 \n\n命令：` nmap 116.7.249.146`\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-4.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-4 扫描主机的输出\n\n### 扫描指定主机的开放端口，系统版本等信息\n\n命令： `nmap -A 192.168.100.52`\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-5.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-5 扫描开发端口的详细输出\n\n[更多命令的高级用法](https://www.cnblogs.com/nmap/p/6232969.html)， [更多扫描方式](https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html)\n\n## 客户端使用\n\n### 扫描所有主机所有端口 \n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-6.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-1 扫描结果标准输出\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-7.png)\n\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-2 扫描结果图形化显示\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-8.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-3 主机明细显示\n\n- 扫描结果导出建议使用XML格式，其中开头有乱码。PDF或其他格式不能正常显示。\n\n[更多命令的高级用法](https://www.cnblogs.com/nmap/p/6232969.html)， [更多扫描方式](https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html)\n\n### 扫描出的状态说明\n\n`Open`：端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务。\n\n`Closed`：端口处于关闭状态。例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口，而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭的端口可能会处于open的状态。\n\n`Filtered（过滤的）`：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。\n\n`Unfiltered（未被过滤的）`，当nmap不能确定端口是否开放的时候所打上的状态，这种状态和filtered的区别在于：unfiltered的端口能被nmap访问，但是nmap根据返回的报文无法确定端口的开放状态，而filtered的端口直接就没就没能够被nmap访问。端口被定义为Unfilterd只会发生在TCP ack扫描类型时当返回RST的报文。而端口被定义为filtered 状态的原因是是报文被防火墙设备，路由器规则，或者防火墙软件拦截，无法送达到端口，这通常表现为发送NMAP的主机收到ICMP报错报文，如：TYPE为3，code为13的报文（通信被认为的禁止 communication administratively prohibited），或者主机通过多次重复发送没有收到任何回应）。\n\nOpen\\|filtered状态，这种状态主要是nmap无法区别端口处于open状态还是filtered状态。这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型。\n\n`Closed\\|filtered状态`，这种状态主要出现在nmap无法区分端口处于closed还是filtered时。此状态只会出现在IP ID idle scan（这个类型我现在也不太理解，过段时间进行总结一些）中。\n\n### 快速扫描TCP端口 \n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-9.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-4 扫描TCP端口","source":"_posts/Nmap的简单使用.md","raw":"---\ntitle: Nmap的简单使用\ndate: 2019-09-26 20:55:23\ntags: 工具的使用\n---\n\n\n\n# 安装\n\n## 客户端安装\n\n### 打开官网链接\n\n<!-- more -->\n\n[官网地址](https://nmap.org/download.html)\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-1.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-1 官网下载Mac版地址\n\n### 下载客户端，安装完成\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-2.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-2 客户端终端图标\n\n## 终端安装\n\n命令：`brew install nmap`\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-3.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-3 安装完成后再次安装后的终端输出\n\n#  使用\n\n## 在终端的使用 \n\n### 扫描主机所有端口 \n\n命令：` nmap 116.7.249.146`\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-4.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-4 扫描主机的输出\n\n### 扫描指定主机的开放端口，系统版本等信息\n\n命令： `nmap -A 192.168.100.52`\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-5.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 1-5 扫描开发端口的详细输出\n\n[更多命令的高级用法](https://www.cnblogs.com/nmap/p/6232969.html)， [更多扫描方式](https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html)\n\n## 客户端使用\n\n### 扫描所有主机所有端口 \n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-6.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-1 扫描结果标准输出\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-7.png)\n\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-2 扫描结果图形化显示\n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-8.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-3 主机明细显示\n\n- 扫描结果导出建议使用XML格式，其中开头有乱码。PDF或其他格式不能正常显示。\n\n[更多命令的高级用法](https://www.cnblogs.com/nmap/p/6232969.html)， [更多扫描方式](https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html)\n\n### 扫描出的状态说明\n\n`Open`：端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务。\n\n`Closed`：端口处于关闭状态。例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口，而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭的端口可能会处于open的状态。\n\n`Filtered（过滤的）`：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。\n\n`Unfiltered（未被过滤的）`，当nmap不能确定端口是否开放的时候所打上的状态，这种状态和filtered的区别在于：unfiltered的端口能被nmap访问，但是nmap根据返回的报文无法确定端口的开放状态，而filtered的端口直接就没就没能够被nmap访问。端口被定义为Unfilterd只会发生在TCP ack扫描类型时当返回RST的报文。而端口被定义为filtered 状态的原因是是报文被防火墙设备，路由器规则，或者防火墙软件拦截，无法送达到端口，这通常表现为发送NMAP的主机收到ICMP报错报文，如：TYPE为3，code为13的报文（通信被认为的禁止 communication administratively prohibited），或者主机通过多次重复发送没有收到任何回应）。\n\nOpen\\|filtered状态，这种状态主要是nmap无法区别端口处于open状态还是filtered状态。这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型。\n\n`Closed\\|filtered状态`，这种状态主要出现在nmap无法区分端口处于closed还是filtered时。此状态只会出现在IP ID idle scan（这个类型我现在也不太理解，过段时间进行总结一些）中。\n\n### 快速扫描TCP端口 \n\n![](https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-9.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图 2-4 扫描TCP端口","slug":"Nmap的简单使用","published":1,"updated":"2019-09-26T13:04:44.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke1c1000dbfgaddclse4x","content":"<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"客户端安装\"><a href=\"#客户端安装\" class=\"headerlink\" title=\"客户端安装\"></a>客户端安装</h2><h3 id=\"打开官网链接\"><a href=\"#打开官网链接\" class=\"headerlink\" title=\"打开官网链接\"></a>打开官网链接</h3><a id=\"more\"></a>\n\n<p><a href=\"https://nmap.org/download.html\" target=\"_blank\" rel=\"noopener\">官网地址</a></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-1.png\" alt></p>\n<p>​                                                                        图 1-1 官网下载Mac版地址</p>\n<h3 id=\"下载客户端，安装完成\"><a href=\"#下载客户端，安装完成\" class=\"headerlink\" title=\"下载客户端，安装完成\"></a>下载客户端，安装完成</h3><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-2.png\" alt></p>\n<p>​                                                                            图 1-2 客户端终端图标</p>\n<h2 id=\"终端安装\"><a href=\"#终端安装\" class=\"headerlink\" title=\"终端安装\"></a>终端安装</h2><p>命令：<code>brew install nmap</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-3.png\" alt></p>\n<p>​                                                                图 1-3 安装完成后再次安装后的终端输出</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"在终端的使用\"><a href=\"#在终端的使用\" class=\"headerlink\" title=\"在终端的使用\"></a>在终端的使用</h2><h3 id=\"扫描主机所有端口\"><a href=\"#扫描主机所有端口\" class=\"headerlink\" title=\"扫描主机所有端口\"></a>扫描主机所有端口</h3><p>命令：<code>nmap 116.7.249.146</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-4.png\" alt></p>\n<p>​                                                                            图 1-4 扫描主机的输出</p>\n<h3 id=\"扫描指定主机的开放端口，系统版本等信息\"><a href=\"#扫描指定主机的开放端口，系统版本等信息\" class=\"headerlink\" title=\"扫描指定主机的开放端口，系统版本等信息\"></a>扫描指定主机的开放端口，系统版本等信息</h3><p>命令： <code>nmap -A 192.168.100.52</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-5.png\" alt></p>\n<p>​                                                                图 1-5 扫描开发端口的详细输出</p>\n<p><a href=\"https://www.cnblogs.com/nmap/p/6232969.html\" target=\"_blank\" rel=\"noopener\">更多命令的高级用法</a>， <a href=\"https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html\" target=\"_blank\" rel=\"noopener\">更多扫描方式</a></p>\n<h2 id=\"客户端使用\"><a href=\"#客户端使用\" class=\"headerlink\" title=\"客户端使用\"></a>客户端使用</h2><h3 id=\"扫描所有主机所有端口\"><a href=\"#扫描所有主机所有端口\" class=\"headerlink\" title=\"扫描所有主机所有端口\"></a>扫描所有主机所有端口</h3><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-6.png\" alt></p>\n<p>​                                                                    图 2-1 扫描结果标准输出</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-7.png\" alt></p>\n<pre><code>图 2-2 扫描结果图形化显示</code></pre><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-8.png\" alt></p>\n<p>​                                                                        图 2-3 主机明细显示</p>\n<ul>\n<li>扫描结果导出建议使用XML格式，其中开头有乱码。PDF或其他格式不能正常显示。</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/nmap/p/6232969.html\" target=\"_blank\" rel=\"noopener\">更多命令的高级用法</a>， <a href=\"https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html\" target=\"_blank\" rel=\"noopener\">更多扫描方式</a></p>\n<h3 id=\"扫描出的状态说明\"><a href=\"#扫描出的状态说明\" class=\"headerlink\" title=\"扫描出的状态说明\"></a>扫描出的状态说明</h3><p><code>Open</code>：端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务。</p>\n<p><code>Closed</code>：端口处于关闭状态。例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口，而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭的端口可能会处于open的状态。</p>\n<p><code>Filtered（过滤的）</code>：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。</p>\n<p><code>Unfiltered（未被过滤的）</code>，当nmap不能确定端口是否开放的时候所打上的状态，这种状态和filtered的区别在于：unfiltered的端口能被nmap访问，但是nmap根据返回的报文无法确定端口的开放状态，而filtered的端口直接就没就没能够被nmap访问。端口被定义为Unfilterd只会发生在TCP ack扫描类型时当返回RST的报文。而端口被定义为filtered 状态的原因是是报文被防火墙设备，路由器规则，或者防火墙软件拦截，无法送达到端口，这通常表现为发送NMAP的主机收到ICMP报错报文，如：TYPE为3，code为13的报文（通信被认为的禁止 communication administratively prohibited），或者主机通过多次重复发送没有收到任何回应）。</p>\n<p>Open|filtered状态，这种状态主要是nmap无法区别端口处于open状态还是filtered状态。这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型。</p>\n<p><code>Closed\\|filtered状态</code>，这种状态主要出现在nmap无法区分端口处于closed还是filtered时。此状态只会出现在IP ID idle scan（这个类型我现在也不太理解，过段时间进行总结一些）中。</p>\n<h3 id=\"快速扫描TCP端口\"><a href=\"#快速扫描TCP端口\" class=\"headerlink\" title=\"快速扫描TCP端口\"></a>快速扫描TCP端口</h3><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-9.png\" alt></p>\n<p>​                                                                                            图 2-4 扫描TCP端口</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"客户端安装\"><a href=\"#客户端安装\" class=\"headerlink\" title=\"客户端安装\"></a>客户端安装</h2><h3 id=\"打开官网链接\"><a href=\"#打开官网链接\" class=\"headerlink\" title=\"打开官网链接\"></a>打开官网链接</h3>","more":"<p><a href=\"https://nmap.org/download.html\" target=\"_blank\" rel=\"noopener\">官网地址</a></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-1.png\" alt></p>\n<p>​                                                                        图 1-1 官网下载Mac版地址</p>\n<h3 id=\"下载客户端，安装完成\"><a href=\"#下载客户端，安装完成\" class=\"headerlink\" title=\"下载客户端，安装完成\"></a>下载客户端，安装完成</h3><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-2.png\" alt></p>\n<p>​                                                                            图 1-2 客户端终端图标</p>\n<h2 id=\"终端安装\"><a href=\"#终端安装\" class=\"headerlink\" title=\"终端安装\"></a>终端安装</h2><p>命令：<code>brew install nmap</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-3.png\" alt></p>\n<p>​                                                                图 1-3 安装完成后再次安装后的终端输出</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"在终端的使用\"><a href=\"#在终端的使用\" class=\"headerlink\" title=\"在终端的使用\"></a>在终端的使用</h2><h3 id=\"扫描主机所有端口\"><a href=\"#扫描主机所有端口\" class=\"headerlink\" title=\"扫描主机所有端口\"></a>扫描主机所有端口</h3><p>命令：<code>nmap 116.7.249.146</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-4.png\" alt></p>\n<p>​                                                                            图 1-4 扫描主机的输出</p>\n<h3 id=\"扫描指定主机的开放端口，系统版本等信息\"><a href=\"#扫描指定主机的开放端口，系统版本等信息\" class=\"headerlink\" title=\"扫描指定主机的开放端口，系统版本等信息\"></a>扫描指定主机的开放端口，系统版本等信息</h3><p>命令： <code>nmap -A 192.168.100.52</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-5.png\" alt></p>\n<p>​                                                                图 1-5 扫描开发端口的详细输出</p>\n<p><a href=\"https://www.cnblogs.com/nmap/p/6232969.html\" target=\"_blank\" rel=\"noopener\">更多命令的高级用法</a>， <a href=\"https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html\" target=\"_blank\" rel=\"noopener\">更多扫描方式</a></p>\n<h2 id=\"客户端使用\"><a href=\"#客户端使用\" class=\"headerlink\" title=\"客户端使用\"></a>客户端使用</h2><h3 id=\"扫描所有主机所有端口\"><a href=\"#扫描所有主机所有端口\" class=\"headerlink\" title=\"扫描所有主机所有端口\"></a>扫描所有主机所有端口</h3><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-6.png\" alt></p>\n<p>​                                                                    图 2-1 扫描结果标准输出</p>\n<p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-7.png\" alt></p>\n<pre><code>图 2-2 扫描结果图形化显示</code></pre><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-8.png\" alt></p>\n<p>​                                                                        图 2-3 主机明细显示</p>\n<ul>\n<li>扫描结果导出建议使用XML格式，其中开头有乱码。PDF或其他格式不能正常显示。</li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/nmap/p/6232969.html\" target=\"_blank\" rel=\"noopener\">更多命令的高级用法</a>， <a href=\"https://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html\" target=\"_blank\" rel=\"noopener\">更多扫描方式</a></p>\n<h3 id=\"扫描出的状态说明\"><a href=\"#扫描出的状态说明\" class=\"headerlink\" title=\"扫描出的状态说明\"></a>扫描出的状态说明</h3><p><code>Open</code>：端口处于开放状态，例如：当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务。</p>\n<p><code>Closed</code>：端口处于关闭状态。例如：TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口，而且，只是在我们扫描的这个时刻为关闭，当我们在另一个时间段进行扫描的时候，这些关闭的端口可能会处于open的状态。</p>\n<p><code>Filtered（过滤的）</code>：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。</p>\n<p><code>Unfiltered（未被过滤的）</code>，当nmap不能确定端口是否开放的时候所打上的状态，这种状态和filtered的区别在于：unfiltered的端口能被nmap访问，但是nmap根据返回的报文无法确定端口的开放状态，而filtered的端口直接就没就没能够被nmap访问。端口被定义为Unfilterd只会发生在TCP ack扫描类型时当返回RST的报文。而端口被定义为filtered 状态的原因是是报文被防火墙设备，路由器规则，或者防火墙软件拦截，无法送达到端口，这通常表现为发送NMAP的主机收到ICMP报错报文，如：TYPE为3，code为13的报文（通信被认为的禁止 communication administratively prohibited），或者主机通过多次重复发送没有收到任何回应）。</p>\n<p>Open|filtered状态，这种状态主要是nmap无法区别端口处于open状态还是filtered状态。这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型。</p>\n<p><code>Closed\\|filtered状态</code>，这种状态主要出现在nmap无法区分端口处于closed还是filtered时。此状态只会出现在IP ID idle scan（这个类型我现在也不太理解，过段时间进行总结一些）中。</p>\n<h3 id=\"快速扫描TCP端口\"><a href=\"#快速扫描TCP端口\" class=\"headerlink\" title=\"快速扫描TCP端口\"></a>快速扫描TCP端口</h3><p><img src=\"https://raw.githubusercontent.com/Xiahaiquan/BlogGraphBed/master/HowToUseTheNmap/1-9.png\" alt></p>\n<p>​                                                                                            图 2-4 扫描TCP端口</p>"},{"title":"Nmap的详细说明","date":"2019-09-26T12:56:12.000Z","_content":"\n# 描述\n\n- Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。\n\n  <!-- more -->\n\n- Nmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 `open`(开放的)，`filtered`(被过滤的)， `closed`(关闭的)，或者`unfiltered`(未被过滤的)。 `Open`(开放的)意味着目标机器上的应用程序正在该端口监听连接/报文。 `filtered`(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是`open`(开放的) 还是 `closed`(关闭的)。 `closed`(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 `unfiltered`(未被过滤的) 如果Nmap报告状态组合 `open|filtered` 和 `closed|filtered`时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (`-sO`)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。\n\n- 除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。\n\n\n\n# 选项概要\n\n```\nNmap 7.80SVN ( https://nmap.org )\nUsage: nmap [Scan Type(s)] [Options] {target specification}\nTARGET SPECIFICATION:\n  Can pass hostnames, IP addresses, networks, etc.\n  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254\n  -iL <inputfilename>: Input from list of hosts/networks\n  -iR <num hosts>: Choose random targets\n  --exclude <host1[,host2][,host3],...>: Exclude hosts/networks\n  --excludefile <exclude_file>: Exclude list from file\nHOST DISCOVERY:\n  -sL: List Scan - simply list targets to scan\n  -sn: Ping Scan - disable port scan\n  -Pn: Treat all hosts as online -- skip host discovery\n  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports\n  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes\n  -PO[protocol list]: IP Protocol Ping\n  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]\n  --dns-servers <serv1[,serv2],...>: Specify custom DNS servers\n  --system-dns: Use OS's DNS resolver\n  --traceroute: Trace hop path to each host\nSCAN TECHNIQUES:\n  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans\n  -sU: UDP Scan\n  -sN/sF/sX: TCP Null, FIN, and Xmas scans\n  --scanflags <flags>: Customize TCP scan flags\n  -sI <zombie host[:probeport]>: Idle scan\n  -sY/sZ: SCTP INIT/COOKIE-ECHO scans\n  -sO: IP protocol scan\n  -b <FTP relay host>: FTP bounce scan\nPORT SPECIFICATION AND SCAN ORDER:\n  -p <port ranges>: Only scan specified ports\n    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9\n  --exclude-ports <port ranges>: Exclude the specified ports from scanning\n  -F: Fast mode - Scan fewer ports than the default scan\n  -r: Scan ports consecutively - don't randomize\n  --top-ports <number>: Scan <number> most common ports\n  --port-ratio <ratio>: Scan ports more common than <ratio>\nSERVICE/VERSION DETECTION:\n  -sV: Probe open ports to determine service/version info\n  --version-intensity <level>: Set from 0 (light) to 9 (try all probes)\n  --version-light: Limit to most likely probes (intensity 2)\n  --version-all: Try every single probe (intensity 9)\n  --version-trace: Show detailed version scan activity (for debugging)\nSCRIPT SCAN:\n  -sC: equivalent to --script=default\n  --script=<Lua scripts>: <Lua scripts> is a comma separated list of\n           directories, script-files or script-categories\n  --script-args=<n1=v1,[n2=v2,...]>: provide arguments to scripts\n  --script-args-file=filename: provide NSE script args in a file\n  --script-trace: Show all data sent and received\n  --script-updatedb: Update the script database.\n  --script-help=<Lua scripts>: Show help about scripts.\n           <Lua scripts> is a comma-separated list of script-files or\n           script-categories.\nOS DETECTION:\n  -O: Enable OS detection\n  --osscan-limit: Limit OS detection to promising targets\n  --osscan-guess: Guess OS more aggressively\nTIMING AND PERFORMANCE:\n  Options which take <time> are in seconds, or append 'ms' (milliseconds),\n  's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m).\n  -T<0-5>: Set timing template (higher is faster)\n  --min-hostgroup/max-hostgroup <size>: Parallel host scan group sizes\n  --min-parallelism/max-parallelism <numprobes>: Probe parallelization\n  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout <time>: Specifies\n      probe round trip time.\n  --max-retries <tries>: Caps number of port scan probe retransmissions.\n  --host-timeout <time>: Give up on target after this long\n  --scan-delay/--max-scan-delay <time>: Adjust delay between probes\n  --min-rate <number>: Send packets no slower than <number> per second\n  --max-rate <number>: Send packets no faster than <number> per second\nFIREWALL/IDS EVASION AND SPOOFING:\n  -f; --mtu <val>: fragment packets (optionally w/given MTU)\n  -D <decoy1,decoy2[,ME],...>: Cloak a scan with decoys\n  -S <IP_Address>: Spoof source address\n  -e <iface>: Use specified interface\n  -g/--source-port <portnum>: Use given port number\n  --proxies <url1,[url2],...>: Relay connections through HTTP/SOCKS4 proxies\n  --data <hex string>: Append a custom payload to sent packets\n  --data-string <string>: Append a custom ASCII string to sent packets\n  --data-length <num>: Append random data to sent packets\n  --ip-options <options>: Send packets with specified ip options\n  --ttl <val>: Set IP time-to-live field\n  --spoof-mac <mac address/prefix/vendor name>: Spoof your MAC address\n  --badsum: Send packets with a bogus TCP/UDP/SCTP checksum\nOUTPUT:\n  -oN/-oX/-oS/-oG <file>: Output scan in normal, XML, s|<rIpt kIddi3,\n     and Grepable format, respectively, to the given filename.\n  -oA <basename>: Output in the three major formats at once\n  -v: Increase verbosity level (use -vv or more for greater effect)\n  -d: Increase debugging level (use -dd or more for greater effect)\n  --reason: Display the reason a port is in a particular state\n  --open: Only show open (or possibly open) ports\n  --packet-trace: Show all packets sent and received\n  --iflist: Print host interfaces and routes (for debugging)\n  --append-output: Append to rather than clobber specified output files\n  --resume <filename>: Resume an aborted scan\n  --stylesheet <path/URL>: XSL stylesheet to transform XML output to HTML\n  --webxml: Reference stylesheet from Nmap.Org for more portable XML\n  --no-stylesheet: Prevent associating of XSL stylesheet w/XML output\nMISC:\n  -6: Enable IPv6 scanning\n  -A: Enable OS detection, version detection, script scanning, and traceroute\n  --datadir <dirname>: Specify custom Nmap data file location\n  --send-eth/--send-ip: Send using raw ethernet frames or IP packets\n  --privileged: Assume that the user is fully privileged\n  --unprivileged: Assume the user lacks raw socket privileges\n  -V: Print version number\n  -h: Print this help summary page.\nEXAMPLES:\n  nmap -v -A scanme.nmap.org\n  nmap -v -sn 192.168.0.0/16 10.0.0.0/8\n  nmap -v -iR 10000 -Pn -p 80\nSEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES\n```\n\n\n\n# 目标说明\n\n除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。\n\n有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR`无类别域间路由，Classless Inter-Domain Routing`(是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP`Internet Service Provider`分配给客户。CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet[路由器](https://baike.baidu.com/item/路由器/108294)的负担)风格的地址。您可以附加 一个/*<numbit>*在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 *<numbit>*相同比特的所有IP地址或主机。 例如，192.168.10.0/24将会扫描192.168.10.0 (二进制格式: `11000000 10101000 00001010 00000000`)和192.168.10.255 (二进制格式: `11000000 10101000 00001010 11111111`)之间的256台主机。 192.168.10.40/24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org/16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是/1， 这将会扫描半个互联网。最大值是/32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。\n\nCIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0/16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。\n\nIPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。\n\nNmap命令行接受多个主机说明，它们不必是相同类型。命令**nmap scanme.nmap.org 192.168.0.0/8 10.0.0，1，3-7.0-255**将和您预期的一样执行。\n\n虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：\n\n- `-iL <inputfilename>` (从列表中输入)\n\n  从 *<inputfilename>*中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您*不是*使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用`-iL` 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(`-`)作为文件名。\n\n- `-iR <hostnum>` (随机选择目标)\n\n  对于互联网范围内的调查和研究， 您也许想随机地选择目标。 *<hostnum>* 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 `0` 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令**nmap -sS -PS80 -iR 0 -p 80**随机地找一些网站浏览。\n\n- `--exclude <host1[，host2][，host3]，...>` (排除主机/网络)\n\n  如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。\n\n- `--excludefile <excludefile>` (排除文件中的列表)\n\n  这和`--exclude` 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 *<excludefile>*提供的，而不是在命令行上输入的。\n\n\n\n# 主机发现\n\n任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。\n\n由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(`-sL`)或者 通过关闭ping (`-P0`)跳过ping的步骤，也可以使用多个端口把TCP SYN/ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0/8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。\n\n如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用`connect()`系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用`-PA -PE`选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。\n\n`-P*`选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口/标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 `-P*`选项，ARP发现(`-PR`)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。\n\n下列选项控制主机发现。\n\n- `-sL` (列表扫描)\n\n  列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， `fw.chi.playboy.com`是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 `-P0`选项的介绍。\n\n- `-sP` (Ping扫描)\n\n  该选项告诉Nmap*仅仅* 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。`-sP`选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用`connect()`系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(`-PR`)， ，除非使用了`--send-ip`选项。 `-sP`选项可以和除`-P0`)之外的任何发现探测类型`-P*` 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。\n\n- `-P0` (无ping)\n\n  该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用`-P0`禁止 主机发现会使Nmap对*每一个*指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(/16)， 所有 65,536 个IP地址都会被扫描。 `-P0`的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。\n\n- `-PS [portlist]` (TCP SYN Ping)\n\n  该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变`nmap.h`) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 `-PS22，23，25，80，113，1050，35000`)， 在这种情况下，每个端口会被并发地扫描。SYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN/ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN/ACK感到很意外。Nmap并不关心端口开放还是关闭。 无论RST还是SYN/ACK响应都告诉Nmap该主机正在运行。在UNIX机器上，通常只有特权用户 `root` 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN/ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。\n\n- `-PA [portlist]` (TCP ACK Ping)\n\n  TCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。`-PA`选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙/路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter/iptables 防火墙软件提供方便的 `--syn`选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (`-PS`) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter/iptables 通过 `--state`选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 `-PS`又指定`-PA`来即发送SYN又发送ACK。\n\n- `-PU [portlist]` (UDP Ping)\n\n  还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了`--data-length` UDP报文到给定的端口。端口列表的格式和前面讨论过的`-PS`和`-PA`选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变`nmap.h`文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。\n\n- `-PE`; `-PP`; `-PM` (ICMP Ping Types)\n\n  除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见[RFC 1122](http://www.rfc-editor.org/rfc/rfc1122.txt)。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用`-PE`选项打开该回声请求功能。虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 ([RFC 792](http://www.rfc-editor.org/rfc/rfc792.txt))还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用`-PP`和`-PM`选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。\n\n- `-PR` (ARP Ping)\n\n  最常见的Nmap使用场景之一是扫描一个以太局域网。 在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件 地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。 当它收到响应时， Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。 即使指定了不同的ping类型(如 `-PI`或者 `-PS`) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 `--send-ip`。\n\n- `-n` (不用域名解析)\n\n  告诉Nmap *永不*对它发现的活动IP地址进行反向域名解析。 既然DNS一般比较慢，这可以让事情更快些。\n\n- `-R` (为所有目标解析域名)\n\n  告诉Nmap *永远* 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。\n\n- `--system-dns` (使用系统域名解析器)\n\n  默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug--如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。\n\n# 端口扫描基础\n\n虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 **nmap<target>**这个简单的命令扫描主机*<target>*上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: `open`(开放的)， `closed`(关闭的)，`filtered`(被过滤的)， `unfiltered`(未被过滤的)， `open|filtered(开放或者被过滤的)`，或者 `closed|filtered(关闭或者被过滤的)`。\n\n这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135/tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 `filtered`(被过滤的)。\n\n**Nmap所识别的6个端口状态。**\n\n- open(开放的)\n\n  应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。\n\n- closed(关闭的)\n\n  关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。\n\n- filtered(被过滤的)\n\n  由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。\n\n- unfiltered(未被过滤的)\n\n  未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。\n\n- open|filtered(开放或者被过滤的)\n\n  当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。\n\n- closed|filtered(关闭或者被过滤的)\n\n  该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。\n\n\n\n# 端口扫描技术\n\n作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。\n\n大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。\n\n虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。\n\n这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(`-sU`)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是`-s*<C>*`， 其中*<C>* 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(`-b`)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。\n\n- `-sS` (TCP SYN扫描)\n\n  SYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin/Null/Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分`open`(开放的)， `closed`(关闭的)，和`filtered`(被过滤的) 状态它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。\n\n- `-sT` (TCP connect()扫描)\n\n  当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建`connect()` 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 `connect()`调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。\n\n- `-sU` (UDP扫描)\n\n  虽然互联网上很多流行的服务运行在TCP 协议上，[UDP](http://www.rfc-editor.org/rfc/rfc768.txt)服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161/162，和67/68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。UDP扫描用`-sU`选项激活。它可以和TCP扫描如 SYN扫描 (`-sS`)结合使用来同时检查两种协议。UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是`closed`(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是`filtered`(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是`open`(开放的)。 如果几次重试后还没有响应，该端口就被认为是 `open|filtered`(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(`-sV`)帮助区分真正的开放端口和被过滤的端口。UDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见`net/ipv4/icmp。c`)。Nmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用`--host-timeout`跳过慢速的 主机。\n\n- `-sN`; `-sF`; `-sX` (TCP Null，FIN，and Xmas扫描)\n\n  这三种扫描类型 (甚至用下一节描述的 `--scanflags` 选项的更多类型) 在[TCP RFC](http://www.rfc-editor.org/rfc/rfc793.txt) 中发掘了一个微妙的方法来区分`open`(开放的)和 `closed`(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的.... 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：Null扫描 (`-sN`)不设置任何标志位(tcp标志头是0)FIN扫描 (`-sF`)只设置TCP FIN标志位。Xmas扫描 (`-sX`)设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是`closed`(关闭的)，而没有响应则意味着 端口是`open|filtered(开放或者被过滤的)`。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 `被过滤的`。这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 -- 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为`closed`(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS/400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别`open`(开放的)端口和一些特定的`filtered`(被过滤的)端口，从而返回 `open|filtered(开放或者被过滤的)`。\n\n- `-sA` (TCP ACK扫描)\n\n  这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定`open`(开放的)或者 `open|filtered(开放或者过滤的)`)端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。ACK扫描探测报文只设置ACK标志位(除非您使用 `--scanflags`)。当扫描未被过滤的系统时， `open`(开放的)和`closed`(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 `unfiltered`(未被过滤的)，意思是 ACK报文不能到达，但至于它们是`open`(开放的)或者 `closed`(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 `filtered`(被过滤的)。\n\n- `-sW` (TCP窗口扫描)\n\n  除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印`unfiltered`， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 `unfiltered`， 而是根据TCP窗口值是正数还是0，分别把端口标记为`open`或者 `closed`该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口`closed`。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 `closed`，而一些常见的端口 (如 22， 25，53) 是 `filtered`，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。\n\n- `-sM` (TCP Maimon扫描)\n\n  Maimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN/ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。\n\n- `--scanflags` (定制的TCP扫描)\n\n  真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 `--scanflags`选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！`--scanflags`选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是`URG`， `ACK`，`PSH`，`RST`，`SYN`，and `FIN`的任何组合就行。例如，`--scanflags URGACKPSHRSTSYNFIN`设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。除了设置需要的标志位，您也可以设置 TCP扫描类型(如`-sA`或者`-sF`)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 `filtered`端口，而FIN扫描则认为是 `open|filtered`。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。\n\n- `-sI <zombie host[:probeport]>` (Idlescan)\n\n  这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在https://nmap.org/book/idlescan.html。除了极端隐蔽(由于它不从真实IP地址发送任何报文)， 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表*从zombie 主机的角度。*显示开放的端口。 因此您可以尝试用您认为(通过路由器/包过滤规则)可能被信任的 zombies扫描目标。如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。\n\n- `-sO` (IP协议扫描)\n\n  IP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 `-p`选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP *协议*不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为`open`。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 `closed`。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 `filtered`(虽然同时他们证明ICMP是 `open` )。如果重试之后仍没有收到响应， 该协议就被标记为`open|filtered`\n\n- `-b <ftp relay host>` (FTP弹跳扫描)\n\n  FTP协议的一个有趣特征([RFC 959](http://www.rfc-editor.org/rfc/rfc959.txt)) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用`-b`选项支持ftp弹跳扫描。参数格式是 *<username>*:*<password>*@*<server>*:*<port>*。 *<Server>* 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略*<username>*:*<password>*， 如果服务器上开放了匿名用户(user:`anonymous` password:`-wwwuser@`)。 端口号(以及前面的冒号) 也可以省略，如果*<server>*使用默认的FTP端口(21)。当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。\n\n\n\n# 端口说明和扫描顺序\n\n除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及`nmap-services` 文件中列出的更高的端口在扫描。\n\n- `-p <port ranges>` (只扫描指定的端口)\n\n  该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及/或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 `-p-`从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(`-sO`)，该选项指定您希望扫描的协议号 (0-255)。当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上`T:` 或者`U:`指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 `-p U:53，111，137，T:21-25，80，139，8080` 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 `-sU` ，以及至少一个TCP扫描类型(如 `-sS`，`-sF`，或者 `-sT`)。如果没有给定协议限定符， 端口号会被加到所有协议列表。\n\n- `-F` (快速 (有限的端口) 扫描)\n\n  在nmap的`nmap-services` 文件中(对于`-sO`，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用`--datadir`选项指定您自己的 小小的`nmap-services`文件 ，差别会很惊人。\n\n- `-r` (不要按随机顺序扫描端口)\n\n  默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定`-r`来顺序端口扫描。\n\n\n\n# 服务和版本探测\n\n把Nmap指向一个远程机器，它可能告诉您 端口25/tcp，80/tcp，和53/udp是开放的。使用包含大约2,200个著名的服务的 `nmap-services`数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 -- 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。\n\n即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。\n\n在用某种其它类型的扫描方法发现TCP 和/或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 `nmap-service-probes` 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (`-sR`)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为`open|filtered`。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 `open|filtered` TCP端口用同样的方法对待。 注意Nmap `-A`选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在 https://nmap.org/vscan/。\n\n当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。\n\n用下列的选项打开和控制版本探测。\n\n- `-sV` (版本探测)\n\n  打开版本探测。 您也可以用`-A`同时打开操作系统探测和版本探测。\n\n- `--allports` (不为版本探测排除任何端口)\n\n  默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除`nmap-service-probes` 中的`Exclude`指示符改变， 您也可以不理会任何`Exclude`指示符，指定`--allports`扫描所有端口\n\n- `--version-intensity <intensity>` (设置 版本扫描强度)\n\n  当进行版本扫描(`-sV`)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过`nmap-service-probes` `ports`指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。\n\n- `--version-light` (打开轻量级模式)\n\n  这是 `--version-intensity 2`的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。\n\n- `--version-all` (尝试每个探测)\n\n  `--version-intensity 9`的别名， 保证对每个端口尝试每个探测报文。\n\n- `--version-trace` (跟踪版本扫描活动)\n\n  这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用`--packet-trace`所得到的信息的子集。\n\n- `-sR` (RPC扫描)\n\n  这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP/UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和**rpcinfo -p**一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(`-sV`)的一部分自动打开。 由于版本探测包括它并且全面得多，`-sR`很少被需要。\n\n# 操作系统探测\n\nNmap最著名的功能之一是用TCP/IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库`nmap-os-fingerprints`中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。\n\n如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。\n\n操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(`-v`)下只以 普通的方式输出，如果同时使用`-O`，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。\n\nhttps://nmap.org/book/osdetect.html 文档使用多种语言描述了版本检测的方式、使用和定制。\n\n采用下列选项启用和控制操作系统检测:\n\n- `-O` (启用操作系统检测)\n\n  也可以使用`-A`来同时启用操作系统检测和版本检测。\n\n- `--osscan-limit` (针对指定的目标进行操作系统检测)\n\n  如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用`-P0`扫描多个主机时。这个选项仅在使用 `-O`或`-A` 进行操作系统检测时起作用。\n\n- `--osscan-guess`; `--fuzzy` (推测操作系统检测结果)\n\n  当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。\n\n# 时间和性能\n\nNmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(**nmap <hostname>**)需要1/5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。\n\n改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。\n\n- `--min-hostgroup <milliseconds>`; `--max-hostgroup <milliseconds>` (调整并行扫描组的大小)\n\n  Nmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。`--max-hostgroup`选项用于说明使用最大的组，Nmap不 会超出这个大小。`--min-hostgroup`选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。\n\n- `--min-parallelism <milliseconds>`; `--max-parallelism <milliseconds>` (调整探测报文的并行度)\n\n  这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。最常见的应用是`--min-parallelism`值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。`--max-parallelism`选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择`--scan-delay`同时使用非常有用，虽然 这个选项本身的用途已经很好。\n\n- `--min-rtt-timeout <milliseconds>`， `--max-rtt-timeout <milliseconds>`， `--initial-rtt-timeout <milliseconds>` (调整探测报文超时)\n\n  Nmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。这些选项以毫秒为单位，采用小的`--max-rtt-timeout`值，使 `--initial-rtt-timeout`值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(`-P0`)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。如果所有的主机都在本地网络，对于`--max-rtt-timeout`值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 `--initial-rtt-timeout`设成这个时间的2倍，`--max-rtt-timeout` 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。`--min-rtt-timeout`这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。\n\n- `--host-timeout <milliseconds>` (放弃低速目标主机)\n\n  由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要*很长*的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 `--host-timeout`选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。\n\n- `--scan-delay <milliseconds>`; `--max-scan-delay <milliseconds>` (调整探测报文的时间间隔)\n\n  这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒 只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。`--scan-delay` 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。`--scan-delay`的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS/IPS)。\n\n- `-T <Paranoid|Sneaky|Polite|Normal|Aggressive|Insane>` (设置时间模板)\n\n  上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用`-T`选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此`-T3` 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，`-T4` 针对TCP端口禁止动态扫描延迟超过10ms，`-T5`对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 `-T4`，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。如果用于有足够的带宽或以太网连接，仍然建议使用`-T4`选项。 有些用户喜欢`-T5`选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用`-T2`选项。他们并没意识到`-T Polite`选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(`-T3`)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。虽然`-T0`和`-T1`选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的`-T0`和`-T1`选项。`T0`选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。`T1`和`T2`选项比较类似， 探测报文间隔分别为15秒和0.4秒。`T3`是Nmap的默认选项，包含了并行扫描。 `T4`选项与 `--max-rtt-timeout 1250 --initial-rtt-timeout 500` 等价，最大TCP扫描延迟为10ms。`T5`等价于 `--max-rtt-timeout 300 --min-rtt-timeout 50 --initial-rtt-timeout 250 --host-timeout 900000`，最大TCP扫描延迟为5ms。\n\n# 防火墙/IDS躲避和哄骗\n\n很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。\n\n类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。\n\n除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵*预防*系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。\n\n有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。\n\nNmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。\n\n- `-f` (报文分段); `--mtu` (使用指定的MTU)\n\n  `-f`选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用`-f`可使用 16字节的分段(减少分段数量)。使用`--mtu`选项可 以自定义偏移的大小，使用时不需要`-f`，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用`--send-eth`选项以避开IP层而直接 发送原始的以太网帧。\n\n- `-D <decoy1 [，decoy2][，ME]，...>` (使用诱饵隐蔽扫描)\n\n  为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 `ME`选项说明。如果在第6个位置或 更后的位置使用`ME`选项，一些常用 端口扫描检测器(如Solar Designer's excellent scanlogd)就不会报告 这个真实IP。如果不使用`ME`选项，Nmap 将真实IP放在一个随机的位置注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(`-O`)。在进行版 本检测或TCP连接扫描时，诱饵无效。使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。\n\n- `-S <IP_Address>` (源地址哄骗)\n\n  在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用`-S`选项并说明所需发送包的接口IP地址。这个标志的另一个用处是哄骗性的扫描，使得目标认为是*另 一个地址*在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ `-e`选项常在这种情况下使用，也可采用`-P0`选项。\n\n- `-e <interface>` (使用指定的接口)\n\n  告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。\n\n- `--source-port <portnumber>;` `-g <portnumber>` (源端口哄骗)\n\n  仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。Nmap提供了`-g`和`--source-port`选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略`--source-port`选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。\n\n- `--data-length <number>` (发送报文时 附加随机数据)\n\n  正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(`-O`)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。\n\n- `--ttl <value>` (设置IP time-to-live域)\n\n  设置IPv4报文的time-to-live域为指定的值。\n\n- `--randomize-hosts` (对目标主机的顺序随机排列)\n\n  告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大`nmap.h`文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (`-sL -n -oN*<filename>*`)，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用`-iL`提供给Nmap。\n\n- `--spoof-mac <mac address，prefix，or vendor name>` (MAC地址哄骗)\n\n  要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 `--send-eth`选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过`nmap-mac-prefixes`查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的`--spoof-mac`参数有， `Apple`， `0`，`01:02:03:04:05:06`， `deadbeefcafe`，`0020F2`， 和`Cisco`.\n\n# 输入\n\n任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和 易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些 方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理 的XML格式。\n\n除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。\n\nNmap提供5种不同的输出格式。默认的方式是`interactive output`， 发送给标准输出(stdout)。`normal output`方式类似于 `interactive`，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。\n\nXML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。\n\n另两种输出类型比较简单，`grepable output`格式，在一行中包含目标主机最多的信息；`sCRiPt KiDDi3 0utPUt` 格式，用于考虑自己的用户 |<-r4d。\n\n交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项`-oX myscan.xml -oN myscan.nmap`。 为便于描述的简化，本章使用类似于`myscan.xml`的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。\n\n在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令**nmap -oX myscan.xml target**将 输出XML至`myscan.xml`，并在stdout 上打印相同的交互式结果，而此时`-oX`选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令**nmap -oX - target**只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。\n\n与其它Nmap参数不同，日志文件选项的空格(如`-oX`)和 文件名或连字符是必需的。如果省略了标记，例如`-oG-`或 `-oXscan.xml`，Nmap的向后兼容特点将建立 *标准格式*的输出文件，相应的文件名为`G-`和 `Xscan.xml`。\n\nNmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项 如下所述。\n\n**Nmap输出格式**\n\n- `-oN <filespec>` (标准输出)\n\n  要求将`标准输出`直接写入指定 的文件。如上所述，这个格式与`交互式输出` 略有不同。\n\n- `-oX <filespec>` (XML输出)\n\n  要求`XML输出`直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在 https://nmap.org/data/nmap.dtd获取。XML提供了可供软件解析的稳定格式输出，主要的计算机 语言都提供了免费的XML解析器，如C/C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的[Nmap::Scanner](http://sourceforge.net/projects/nmap-scanner/) 和[Nmap::Parser](http://www.nmapparser.com/)。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。XML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于`nmap.xsl`文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，`--stylesheet` 选项可用于建立可移植的XML文件。\n\n- `-oS <filespec>` (ScRipT KIdd|3 oUTpuT)\n\n  脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 'l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。\n\n- `-oG <filespec>` (Grep输出)\n\n  这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。Grep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有`主机`，`端口`， `协议`，`忽略状态`， `操作系统`，`序列号`， `IPID`和`状态`。这些域中最重要的是`Ports`，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由/分隔。这些子域有：`端口号`， `状态`，`协议`， `拥有者`，`服务`， `SunRPCinfo`和`版本信息`。对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可 查阅http://www.unspecific.com/nmap-oG-output。\n\n- `-oA <basename>` (输出至所有格式)\n\n  为使用方便，利用`-oA*<basename>*`选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 *<basename>*.nmap，*<basename>*.xml和 *<basename>*.gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用`~/nmaplogs/foocorp/`， 在Window中，使用`c:\\hacking\\sco` on Windows。\n\n**细节和调试选项**\n\n- `-v` (提高输出信息的详细度)\n\n  通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。\n\n- `-d [level]` (提高或设置调试级别)\n\n  当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(`-v`)时，可启用命令行参数 (`-d`)，多次使用可提高调试级别。也可在`-d` 后面使用参数设置调试级别。例如，`-d9`设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，`Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 ==> srtt: 14987 rttvar: 14987 to: 100000`。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。\n\n- `--packet-trace` (跟踪发送和接收的报文)\n\n  要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如`-p20-30`。 如果只需进行版本检测，使用`--version-trace`。\n\n- `--iflist` (列举接口和路由)\n\n  输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。\n\n**其它输出选项**\n\n- `--append-output` (在输出文件中添加)\n\n  当使用文件作为输出格式，如`-oX`或`-oN`， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用`--append-output`选项。所有指 定的输出文件都被添加。但对于XML(`-oX`)扫描输出 文件无效，无法正常解析，需要手工修改。\n\n- `--resume <filename>` (继续中断的扫描)\n\n  一些扩展的Nmap运行需要很长的时间 -- 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下**ctrl-C** 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (`-oN`)或Grep扫描(`-oG`)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 `--resume`并说明标准/Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如**nmap --resume <logfilename>**。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。\n\n- `--stylesheet <path or URL>` (设置XSL样式表，转换XML输出)\n\n  Nmap提从了XSL样式表`nmap.xsl`，用于查看 或转换XML输出至HTML。XML输出包含了一个`xml-stylesheet`， 直接指向`nmap.xml`文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找`nmap.xsl`文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 `--stylesheet`的参数，必段指明完整的路 径或URL，常见的调用方式是`--stylesheet https://nmap.org/data/nmap.xsl`。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和`nmap.xsl`) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。\n\n- `--no-stylesheet` (忽略XML声明的XSL样式表)\n\n  使用该选项禁止Nmap的XML输出关联任何XSL样式表。 `xml-stylesheet`指示被忽略。\n\n# 其他选项\n\n本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。\n\n- `-6` (启用IPv6扫描)\n\n  从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加`-6`选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如`3ffe:7501:4819:2000:210:f3ff:fe03:14d0`。 除“所关注的端口”行的地址部分为IPv6地址。IPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于https://tb.ipv6.btexact.com/。 此外，还有Hurricane Electric，位于http://ipv6tb.he.net/。6to4隧道是 另一种常用的免费方法。\n\n- `-A` (激烈扫描模式选项)\n\n  这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(`-O`) 和版本扫描(`-sV`)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如`-T4`)或细节选项(`-v`)。\n\n- `--datadir <directoryname>` (说明用户Nmap数据文件位置)\n\n  Nmap在运行时从文件中获得特殊的数据，这些文件有 `nmap-service-probes`， `nmap-services`， `nmap-protocols`， `nmap-rpc`， `nmap-mac-prefixes`和 `nmap-os-fingerprints`。Nmap首先 在`--datadir`选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的`~/.nmap` 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如`/usr/local/share/nmap`或`/usr/share/nmap`。 Nmap查找的最后一个位置是当前目录。\n\n- `--send-eth` (使用原以太网帧发送)\n\n  要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。\n\n- `--send-ip` (在原IP层发送)\n\n  要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是`--send-eth`选项的补充。\n\n- `--privileged` (假定用户具有全部权限)\n\n  告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 `--privileged`在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于`--privileged`选项。\n\n- `-V`; `--version` (打印版本信息)\n\n  打印Nmap版本号并退出。\n\n- `-h`; `--help` (打印帮助摘要面)\n\n  打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。\n\n# 运行时交互\n\n*Nmap目前还不具有这个功能，本节内容可能会增加或删除。*\n\n在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，*小写字母增加* 打印量，*大写字母减少*打印量。\n\n- `v` / `V`\n\n  增加 / 减少细节\n\n- `d` / `D`\n\n  提高 / 降低调试级别\n\n- `p` / `P`\n\n  打开/ 养老报文跟踪\n\n- 其它\n\n  打印的信息类似于：Stats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service ScanService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)\n\n\n\n# 实例\n\n下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用*你自己网络* 的地址/域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。\n\n如果是为了测试，`scanme.nmap.org` 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告`解析 指定的主机名/IP地址失败：scanme.nmap.org`。这些免 费扫描要求也适用于`scanme2.nmap.org`、 `scanme3.nmap.org`等等，虽然这些 主机目前还不存在。\n\n**nmap -v scanme.nmap.org**\n\n这个选项扫描主机`scanme.nmap.org`中 所有的保留TCP端口。选项`-v`启用细节模式。\n\n**nmap -sS -O scanme.nmap.org/24**\n\n进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。\n\n**nmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127**\n\n进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。\n\n**nmap -v -iR 100000 -P0 -p 80**\n\n随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用`-P0`禁止对主机列表。\n\n**nmap -P0 -p80 -oX logs/pb-port80scan.xml -oG logs/pb-port80scan.gnmap 216.163.128.20/20**\n\n扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。\n\n**host -l company.com | cut -d -f 4 | nmap -v -iL -**\n\n进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU/Linux -- 其它系统进行区域传输时有不同的命令。\n\n# Bugs\n\n和作者一样，Nmap也不是完美的，但可以通过发送Bug报告甚至编写 补丁使其更加完善。如果Nmap不能满足要求，首先从https://nmap.org/ 升级最新版本。如果总问题仍然存在，需要进行调查以确定问题是否 已经被解决。在http://seclists.org/尝试搜索出错消息或 浏览Nmap-dev档案，以及仔细阅读使用手册。如果问题还是不能解决，发送 Bug报告至`<dev@nmap.org>`。在报告中包含所有 有关问题的信息，以及所使用的Nmap版本、操作系统版本。问题报告以及 Nmap的使用问题发送给dev@nmap.org比直接发送给Gyodor能更好回答。\n\n解决Bug的代码补丁比Bug报告更受欢迎，在https://nmap.org/data/HACKING 可获得建立补丁文件的基本指令。补丁可发送给nmap-dev(建议) 或直接发给Fyodor。\n\n\n\n\n\n\n\n","source":"_posts/Nmap的详细说明.md","raw":"---\ntitle: Nmap的详细说明\ndate: 2019-09-26 20:56:12\ntags: 工具的使用\n---\n\n# 描述\n\n- Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。\n\n  <!-- more -->\n\n- Nmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 `open`(开放的)，`filtered`(被过滤的)， `closed`(关闭的)，或者`unfiltered`(未被过滤的)。 `Open`(开放的)意味着目标机器上的应用程序正在该端口监听连接/报文。 `filtered`(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是`open`(开放的) 还是 `closed`(关闭的)。 `closed`(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 `unfiltered`(未被过滤的) 如果Nmap报告状态组合 `open|filtered` 和 `closed|filtered`时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (`-sO`)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。\n\n- 除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。\n\n\n\n# 选项概要\n\n```\nNmap 7.80SVN ( https://nmap.org )\nUsage: nmap [Scan Type(s)] [Options] {target specification}\nTARGET SPECIFICATION:\n  Can pass hostnames, IP addresses, networks, etc.\n  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254\n  -iL <inputfilename>: Input from list of hosts/networks\n  -iR <num hosts>: Choose random targets\n  --exclude <host1[,host2][,host3],...>: Exclude hosts/networks\n  --excludefile <exclude_file>: Exclude list from file\nHOST DISCOVERY:\n  -sL: List Scan - simply list targets to scan\n  -sn: Ping Scan - disable port scan\n  -Pn: Treat all hosts as online -- skip host discovery\n  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports\n  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes\n  -PO[protocol list]: IP Protocol Ping\n  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]\n  --dns-servers <serv1[,serv2],...>: Specify custom DNS servers\n  --system-dns: Use OS's DNS resolver\n  --traceroute: Trace hop path to each host\nSCAN TECHNIQUES:\n  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans\n  -sU: UDP Scan\n  -sN/sF/sX: TCP Null, FIN, and Xmas scans\n  --scanflags <flags>: Customize TCP scan flags\n  -sI <zombie host[:probeport]>: Idle scan\n  -sY/sZ: SCTP INIT/COOKIE-ECHO scans\n  -sO: IP protocol scan\n  -b <FTP relay host>: FTP bounce scan\nPORT SPECIFICATION AND SCAN ORDER:\n  -p <port ranges>: Only scan specified ports\n    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9\n  --exclude-ports <port ranges>: Exclude the specified ports from scanning\n  -F: Fast mode - Scan fewer ports than the default scan\n  -r: Scan ports consecutively - don't randomize\n  --top-ports <number>: Scan <number> most common ports\n  --port-ratio <ratio>: Scan ports more common than <ratio>\nSERVICE/VERSION DETECTION:\n  -sV: Probe open ports to determine service/version info\n  --version-intensity <level>: Set from 0 (light) to 9 (try all probes)\n  --version-light: Limit to most likely probes (intensity 2)\n  --version-all: Try every single probe (intensity 9)\n  --version-trace: Show detailed version scan activity (for debugging)\nSCRIPT SCAN:\n  -sC: equivalent to --script=default\n  --script=<Lua scripts>: <Lua scripts> is a comma separated list of\n           directories, script-files or script-categories\n  --script-args=<n1=v1,[n2=v2,...]>: provide arguments to scripts\n  --script-args-file=filename: provide NSE script args in a file\n  --script-trace: Show all data sent and received\n  --script-updatedb: Update the script database.\n  --script-help=<Lua scripts>: Show help about scripts.\n           <Lua scripts> is a comma-separated list of script-files or\n           script-categories.\nOS DETECTION:\n  -O: Enable OS detection\n  --osscan-limit: Limit OS detection to promising targets\n  --osscan-guess: Guess OS more aggressively\nTIMING AND PERFORMANCE:\n  Options which take <time> are in seconds, or append 'ms' (milliseconds),\n  's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m).\n  -T<0-5>: Set timing template (higher is faster)\n  --min-hostgroup/max-hostgroup <size>: Parallel host scan group sizes\n  --min-parallelism/max-parallelism <numprobes>: Probe parallelization\n  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout <time>: Specifies\n      probe round trip time.\n  --max-retries <tries>: Caps number of port scan probe retransmissions.\n  --host-timeout <time>: Give up on target after this long\n  --scan-delay/--max-scan-delay <time>: Adjust delay between probes\n  --min-rate <number>: Send packets no slower than <number> per second\n  --max-rate <number>: Send packets no faster than <number> per second\nFIREWALL/IDS EVASION AND SPOOFING:\n  -f; --mtu <val>: fragment packets (optionally w/given MTU)\n  -D <decoy1,decoy2[,ME],...>: Cloak a scan with decoys\n  -S <IP_Address>: Spoof source address\n  -e <iface>: Use specified interface\n  -g/--source-port <portnum>: Use given port number\n  --proxies <url1,[url2],...>: Relay connections through HTTP/SOCKS4 proxies\n  --data <hex string>: Append a custom payload to sent packets\n  --data-string <string>: Append a custom ASCII string to sent packets\n  --data-length <num>: Append random data to sent packets\n  --ip-options <options>: Send packets with specified ip options\n  --ttl <val>: Set IP time-to-live field\n  --spoof-mac <mac address/prefix/vendor name>: Spoof your MAC address\n  --badsum: Send packets with a bogus TCP/UDP/SCTP checksum\nOUTPUT:\n  -oN/-oX/-oS/-oG <file>: Output scan in normal, XML, s|<rIpt kIddi3,\n     and Grepable format, respectively, to the given filename.\n  -oA <basename>: Output in the three major formats at once\n  -v: Increase verbosity level (use -vv or more for greater effect)\n  -d: Increase debugging level (use -dd or more for greater effect)\n  --reason: Display the reason a port is in a particular state\n  --open: Only show open (or possibly open) ports\n  --packet-trace: Show all packets sent and received\n  --iflist: Print host interfaces and routes (for debugging)\n  --append-output: Append to rather than clobber specified output files\n  --resume <filename>: Resume an aborted scan\n  --stylesheet <path/URL>: XSL stylesheet to transform XML output to HTML\n  --webxml: Reference stylesheet from Nmap.Org for more portable XML\n  --no-stylesheet: Prevent associating of XSL stylesheet w/XML output\nMISC:\n  -6: Enable IPv6 scanning\n  -A: Enable OS detection, version detection, script scanning, and traceroute\n  --datadir <dirname>: Specify custom Nmap data file location\n  --send-eth/--send-ip: Send using raw ethernet frames or IP packets\n  --privileged: Assume that the user is fully privileged\n  --unprivileged: Assume the user lacks raw socket privileges\n  -V: Print version number\n  -h: Print this help summary page.\nEXAMPLES:\n  nmap -v -A scanme.nmap.org\n  nmap -v -sn 192.168.0.0/16 10.0.0.0/8\n  nmap -v -iR 10000 -Pn -p 80\nSEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES\n```\n\n\n\n# 目标说明\n\n除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。\n\n有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR`无类别域间路由，Classless Inter-Domain Routing`(是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP`Internet Service Provider`分配给客户。CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet[路由器](https://baike.baidu.com/item/路由器/108294)的负担)风格的地址。您可以附加 一个/*<numbit>*在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 *<numbit>*相同比特的所有IP地址或主机。 例如，192.168.10.0/24将会扫描192.168.10.0 (二进制格式: `11000000 10101000 00001010 00000000`)和192.168.10.255 (二进制格式: `11000000 10101000 00001010 11111111`)之间的256台主机。 192.168.10.40/24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org/16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是/1， 这将会扫描半个互联网。最大值是/32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。\n\nCIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0/16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。\n\nIPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。\n\nNmap命令行接受多个主机说明，它们不必是相同类型。命令**nmap scanme.nmap.org 192.168.0.0/8 10.0.0，1，3-7.0-255**将和您预期的一样执行。\n\n虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：\n\n- `-iL <inputfilename>` (从列表中输入)\n\n  从 *<inputfilename>*中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您*不是*使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用`-iL` 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(`-`)作为文件名。\n\n- `-iR <hostnum>` (随机选择目标)\n\n  对于互联网范围内的调查和研究， 您也许想随机地选择目标。 *<hostnum>* 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 `0` 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令**nmap -sS -PS80 -iR 0 -p 80**随机地找一些网站浏览。\n\n- `--exclude <host1[，host2][，host3]，...>` (排除主机/网络)\n\n  如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。\n\n- `--excludefile <excludefile>` (排除文件中的列表)\n\n  这和`--exclude` 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 *<excludefile>*提供的，而不是在命令行上输入的。\n\n\n\n# 主机发现\n\n任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。\n\n由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(`-sL`)或者 通过关闭ping (`-P0`)跳过ping的步骤，也可以使用多个端口把TCP SYN/ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0/8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。\n\n如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用`connect()`系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用`-PA -PE`选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。\n\n`-P*`选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口/标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 `-P*`选项，ARP发现(`-PR`)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。\n\n下列选项控制主机发现。\n\n- `-sL` (列表扫描)\n\n  列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， `fw.chi.playboy.com`是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 `-P0`选项的介绍。\n\n- `-sP` (Ping扫描)\n\n  该选项告诉Nmap*仅仅* 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。`-sP`选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用`connect()`系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(`-PR`)， ，除非使用了`--send-ip`选项。 `-sP`选项可以和除`-P0`)之外的任何发现探测类型`-P*` 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。\n\n- `-P0` (无ping)\n\n  该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用`-P0`禁止 主机发现会使Nmap对*每一个*指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(/16)， 所有 65,536 个IP地址都会被扫描。 `-P0`的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。\n\n- `-PS [portlist]` (TCP SYN Ping)\n\n  该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变`nmap.h`) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 `-PS22，23，25，80，113，1050，35000`)， 在这种情况下，每个端口会被并发地扫描。SYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN/ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN/ACK感到很意外。Nmap并不关心端口开放还是关闭。 无论RST还是SYN/ACK响应都告诉Nmap该主机正在运行。在UNIX机器上，通常只有特权用户 `root` 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN/ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。\n\n- `-PA [portlist]` (TCP ACK Ping)\n\n  TCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。`-PA`选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙/路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter/iptables 防火墙软件提供方便的 `--syn`选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (`-PS`) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter/iptables 通过 `--state`选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 `-PS`又指定`-PA`来即发送SYN又发送ACK。\n\n- `-PU [portlist]` (UDP Ping)\n\n  还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了`--data-length` UDP报文到给定的端口。端口列表的格式和前面讨论过的`-PS`和`-PA`选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变`nmap.h`文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。\n\n- `-PE`; `-PP`; `-PM` (ICMP Ping Types)\n\n  除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见[RFC 1122](http://www.rfc-editor.org/rfc/rfc1122.txt)。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用`-PE`选项打开该回声请求功能。虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 ([RFC 792](http://www.rfc-editor.org/rfc/rfc792.txt))还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用`-PP`和`-PM`选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。\n\n- `-PR` (ARP Ping)\n\n  最常见的Nmap使用场景之一是扫描一个以太局域网。 在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件 地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。 当它收到响应时， Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。 即使指定了不同的ping类型(如 `-PI`或者 `-PS`) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 `--send-ip`。\n\n- `-n` (不用域名解析)\n\n  告诉Nmap *永不*对它发现的活动IP地址进行反向域名解析。 既然DNS一般比较慢，这可以让事情更快些。\n\n- `-R` (为所有目标解析域名)\n\n  告诉Nmap *永远* 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。\n\n- `--system-dns` (使用系统域名解析器)\n\n  默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug--如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。\n\n# 端口扫描基础\n\n虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 **nmap<target>**这个简单的命令扫描主机*<target>*上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: `open`(开放的)， `closed`(关闭的)，`filtered`(被过滤的)， `unfiltered`(未被过滤的)， `open|filtered(开放或者被过滤的)`，或者 `closed|filtered(关闭或者被过滤的)`。\n\n这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135/tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 `filtered`(被过滤的)。\n\n**Nmap所识别的6个端口状态。**\n\n- open(开放的)\n\n  应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。\n\n- closed(关闭的)\n\n  关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。\n\n- filtered(被过滤的)\n\n  由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。\n\n- unfiltered(未被过滤的)\n\n  未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。\n\n- open|filtered(开放或者被过滤的)\n\n  当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。\n\n- closed|filtered(关闭或者被过滤的)\n\n  该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。\n\n\n\n# 端口扫描技术\n\n作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。\n\n大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。\n\n虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。\n\n这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(`-sU`)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是`-s*<C>*`， 其中*<C>* 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(`-b`)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。\n\n- `-sS` (TCP SYN扫描)\n\n  SYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin/Null/Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分`open`(开放的)， `closed`(关闭的)，和`filtered`(被过滤的) 状态它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。\n\n- `-sT` (TCP connect()扫描)\n\n  当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建`connect()` 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 `connect()`调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。\n\n- `-sU` (UDP扫描)\n\n  虽然互联网上很多流行的服务运行在TCP 协议上，[UDP](http://www.rfc-editor.org/rfc/rfc768.txt)服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161/162，和67/68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。UDP扫描用`-sU`选项激活。它可以和TCP扫描如 SYN扫描 (`-sS`)结合使用来同时检查两种协议。UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是`closed`(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是`filtered`(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是`open`(开放的)。 如果几次重试后还没有响应，该端口就被认为是 `open|filtered`(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(`-sV`)帮助区分真正的开放端口和被过滤的端口。UDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见`net/ipv4/icmp。c`)。Nmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用`--host-timeout`跳过慢速的 主机。\n\n- `-sN`; `-sF`; `-sX` (TCP Null，FIN，and Xmas扫描)\n\n  这三种扫描类型 (甚至用下一节描述的 `--scanflags` 选项的更多类型) 在[TCP RFC](http://www.rfc-editor.org/rfc/rfc793.txt) 中发掘了一个微妙的方法来区分`open`(开放的)和 `closed`(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的.... 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：Null扫描 (`-sN`)不设置任何标志位(tcp标志头是0)FIN扫描 (`-sF`)只设置TCP FIN标志位。Xmas扫描 (`-sX`)设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是`closed`(关闭的)，而没有响应则意味着 端口是`open|filtered(开放或者被过滤的)`。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 `被过滤的`。这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 -- 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为`closed`(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS/400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别`open`(开放的)端口和一些特定的`filtered`(被过滤的)端口，从而返回 `open|filtered(开放或者被过滤的)`。\n\n- `-sA` (TCP ACK扫描)\n\n  这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定`open`(开放的)或者 `open|filtered(开放或者过滤的)`)端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。ACK扫描探测报文只设置ACK标志位(除非您使用 `--scanflags`)。当扫描未被过滤的系统时， `open`(开放的)和`closed`(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 `unfiltered`(未被过滤的)，意思是 ACK报文不能到达，但至于它们是`open`(开放的)或者 `closed`(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 `filtered`(被过滤的)。\n\n- `-sW` (TCP窗口扫描)\n\n  除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印`unfiltered`， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 `unfiltered`， 而是根据TCP窗口值是正数还是0，分别把端口标记为`open`或者 `closed`该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口`closed`。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 `closed`，而一些常见的端口 (如 22， 25，53) 是 `filtered`，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。\n\n- `-sM` (TCP Maimon扫描)\n\n  Maimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN/ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。\n\n- `--scanflags` (定制的TCP扫描)\n\n  真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 `--scanflags`选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！`--scanflags`选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是`URG`， `ACK`，`PSH`，`RST`，`SYN`，and `FIN`的任何组合就行。例如，`--scanflags URGACKPSHRSTSYNFIN`设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。除了设置需要的标志位，您也可以设置 TCP扫描类型(如`-sA`或者`-sF`)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 `filtered`端口，而FIN扫描则认为是 `open|filtered`。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。\n\n- `-sI <zombie host[:probeport]>` (Idlescan)\n\n  这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在https://nmap.org/book/idlescan.html。除了极端隐蔽(由于它不从真实IP地址发送任何报文)， 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表*从zombie 主机的角度。*显示开放的端口。 因此您可以尝试用您认为(通过路由器/包过滤规则)可能被信任的 zombies扫描目标。如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。\n\n- `-sO` (IP协议扫描)\n\n  IP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 `-p`选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP *协议*不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为`open`。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 `closed`。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 `filtered`(虽然同时他们证明ICMP是 `open` )。如果重试之后仍没有收到响应， 该协议就被标记为`open|filtered`\n\n- `-b <ftp relay host>` (FTP弹跳扫描)\n\n  FTP协议的一个有趣特征([RFC 959](http://www.rfc-editor.org/rfc/rfc959.txt)) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用`-b`选项支持ftp弹跳扫描。参数格式是 *<username>*:*<password>*@*<server>*:*<port>*。 *<Server>* 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略*<username>*:*<password>*， 如果服务器上开放了匿名用户(user:`anonymous` password:`-wwwuser@`)。 端口号(以及前面的冒号) 也可以省略，如果*<server>*使用默认的FTP端口(21)。当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。\n\n\n\n# 端口说明和扫描顺序\n\n除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及`nmap-services` 文件中列出的更高的端口在扫描。\n\n- `-p <port ranges>` (只扫描指定的端口)\n\n  该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及/或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 `-p-`从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(`-sO`)，该选项指定您希望扫描的协议号 (0-255)。当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上`T:` 或者`U:`指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 `-p U:53，111，137，T:21-25，80，139，8080` 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 `-sU` ，以及至少一个TCP扫描类型(如 `-sS`，`-sF`，或者 `-sT`)。如果没有给定协议限定符， 端口号会被加到所有协议列表。\n\n- `-F` (快速 (有限的端口) 扫描)\n\n  在nmap的`nmap-services` 文件中(对于`-sO`，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用`--datadir`选项指定您自己的 小小的`nmap-services`文件 ，差别会很惊人。\n\n- `-r` (不要按随机顺序扫描端口)\n\n  默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定`-r`来顺序端口扫描。\n\n\n\n# 服务和版本探测\n\n把Nmap指向一个远程机器，它可能告诉您 端口25/tcp，80/tcp，和53/udp是开放的。使用包含大约2,200个著名的服务的 `nmap-services`数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 -- 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。\n\n即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。\n\n在用某种其它类型的扫描方法发现TCP 和/或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 `nmap-service-probes` 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (`-sR`)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为`open|filtered`。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 `open|filtered` TCP端口用同样的方法对待。 注意Nmap `-A`选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在 https://nmap.org/vscan/。\n\n当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。\n\n用下列的选项打开和控制版本探测。\n\n- `-sV` (版本探测)\n\n  打开版本探测。 您也可以用`-A`同时打开操作系统探测和版本探测。\n\n- `--allports` (不为版本探测排除任何端口)\n\n  默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除`nmap-service-probes` 中的`Exclude`指示符改变， 您也可以不理会任何`Exclude`指示符，指定`--allports`扫描所有端口\n\n- `--version-intensity <intensity>` (设置 版本扫描强度)\n\n  当进行版本扫描(`-sV`)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过`nmap-service-probes` `ports`指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。\n\n- `--version-light` (打开轻量级模式)\n\n  这是 `--version-intensity 2`的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。\n\n- `--version-all` (尝试每个探测)\n\n  `--version-intensity 9`的别名， 保证对每个端口尝试每个探测报文。\n\n- `--version-trace` (跟踪版本扫描活动)\n\n  这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用`--packet-trace`所得到的信息的子集。\n\n- `-sR` (RPC扫描)\n\n  这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP/UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和**rpcinfo -p**一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(`-sV`)的一部分自动打开。 由于版本探测包括它并且全面得多，`-sR`很少被需要。\n\n# 操作系统探测\n\nNmap最著名的功能之一是用TCP/IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库`nmap-os-fingerprints`中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。\n\n如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。\n\n操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(`-v`)下只以 普通的方式输出，如果同时使用`-O`，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。\n\nhttps://nmap.org/book/osdetect.html 文档使用多种语言描述了版本检测的方式、使用和定制。\n\n采用下列选项启用和控制操作系统检测:\n\n- `-O` (启用操作系统检测)\n\n  也可以使用`-A`来同时启用操作系统检测和版本检测。\n\n- `--osscan-limit` (针对指定的目标进行操作系统检测)\n\n  如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用`-P0`扫描多个主机时。这个选项仅在使用 `-O`或`-A` 进行操作系统检测时起作用。\n\n- `--osscan-guess`; `--fuzzy` (推测操作系统检测结果)\n\n  当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。\n\n# 时间和性能\n\nNmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(**nmap <hostname>**)需要1/5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。\n\n改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。\n\n- `--min-hostgroup <milliseconds>`; `--max-hostgroup <milliseconds>` (调整并行扫描组的大小)\n\n  Nmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。`--max-hostgroup`选项用于说明使用最大的组，Nmap不 会超出这个大小。`--min-hostgroup`选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。\n\n- `--min-parallelism <milliseconds>`; `--max-parallelism <milliseconds>` (调整探测报文的并行度)\n\n  这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。最常见的应用是`--min-parallelism`值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。`--max-parallelism`选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择`--scan-delay`同时使用非常有用，虽然 这个选项本身的用途已经很好。\n\n- `--min-rtt-timeout <milliseconds>`， `--max-rtt-timeout <milliseconds>`， `--initial-rtt-timeout <milliseconds>` (调整探测报文超时)\n\n  Nmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。这些选项以毫秒为单位，采用小的`--max-rtt-timeout`值，使 `--initial-rtt-timeout`值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(`-P0`)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。如果所有的主机都在本地网络，对于`--max-rtt-timeout`值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 `--initial-rtt-timeout`设成这个时间的2倍，`--max-rtt-timeout` 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。`--min-rtt-timeout`这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。\n\n- `--host-timeout <milliseconds>` (放弃低速目标主机)\n\n  由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要*很长*的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 `--host-timeout`选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。\n\n- `--scan-delay <milliseconds>`; `--max-scan-delay <milliseconds>` (调整探测报文的时间间隔)\n\n  这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒 只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。`--scan-delay` 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。`--scan-delay`的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS/IPS)。\n\n- `-T <Paranoid|Sneaky|Polite|Normal|Aggressive|Insane>` (设置时间模板)\n\n  上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用`-T`选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此`-T3` 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，`-T4` 针对TCP端口禁止动态扫描延迟超过10ms，`-T5`对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 `-T4`，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。如果用于有足够的带宽或以太网连接，仍然建议使用`-T4`选项。 有些用户喜欢`-T5`选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用`-T2`选项。他们并没意识到`-T Polite`选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(`-T3`)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。虽然`-T0`和`-T1`选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的`-T0`和`-T1`选项。`T0`选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。`T1`和`T2`选项比较类似， 探测报文间隔分别为15秒和0.4秒。`T3`是Nmap的默认选项，包含了并行扫描。 `T4`选项与 `--max-rtt-timeout 1250 --initial-rtt-timeout 500` 等价，最大TCP扫描延迟为10ms。`T5`等价于 `--max-rtt-timeout 300 --min-rtt-timeout 50 --initial-rtt-timeout 250 --host-timeout 900000`，最大TCP扫描延迟为5ms。\n\n# 防火墙/IDS躲避和哄骗\n\n很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。\n\n类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。\n\n除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵*预防*系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。\n\n有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。\n\nNmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。\n\n- `-f` (报文分段); `--mtu` (使用指定的MTU)\n\n  `-f`选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用`-f`可使用 16字节的分段(减少分段数量)。使用`--mtu`选项可 以自定义偏移的大小，使用时不需要`-f`，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用`--send-eth`选项以避开IP层而直接 发送原始的以太网帧。\n\n- `-D <decoy1 [，decoy2][，ME]，...>` (使用诱饵隐蔽扫描)\n\n  为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 `ME`选项说明。如果在第6个位置或 更后的位置使用`ME`选项，一些常用 端口扫描检测器(如Solar Designer's excellent scanlogd)就不会报告 这个真实IP。如果不使用`ME`选项，Nmap 将真实IP放在一个随机的位置注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(`-O`)。在进行版 本检测或TCP连接扫描时，诱饵无效。使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。\n\n- `-S <IP_Address>` (源地址哄骗)\n\n  在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用`-S`选项并说明所需发送包的接口IP地址。这个标志的另一个用处是哄骗性的扫描，使得目标认为是*另 一个地址*在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ `-e`选项常在这种情况下使用，也可采用`-P0`选项。\n\n- `-e <interface>` (使用指定的接口)\n\n  告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。\n\n- `--source-port <portnumber>;` `-g <portnumber>` (源端口哄骗)\n\n  仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。Nmap提供了`-g`和`--source-port`选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略`--source-port`选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。\n\n- `--data-length <number>` (发送报文时 附加随机数据)\n\n  正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(`-O`)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。\n\n- `--ttl <value>` (设置IP time-to-live域)\n\n  设置IPv4报文的time-to-live域为指定的值。\n\n- `--randomize-hosts` (对目标主机的顺序随机排列)\n\n  告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大`nmap.h`文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (`-sL -n -oN*<filename>*`)，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用`-iL`提供给Nmap。\n\n- `--spoof-mac <mac address，prefix，or vendor name>` (MAC地址哄骗)\n\n  要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 `--send-eth`选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过`nmap-mac-prefixes`查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的`--spoof-mac`参数有， `Apple`， `0`，`01:02:03:04:05:06`， `deadbeefcafe`，`0020F2`， 和`Cisco`.\n\n# 输入\n\n任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和 易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些 方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理 的XML格式。\n\n除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。\n\nNmap提供5种不同的输出格式。默认的方式是`interactive output`， 发送给标准输出(stdout)。`normal output`方式类似于 `interactive`，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。\n\nXML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。\n\n另两种输出类型比较简单，`grepable output`格式，在一行中包含目标主机最多的信息；`sCRiPt KiDDi3 0utPUt` 格式，用于考虑自己的用户 |<-r4d。\n\n交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项`-oX myscan.xml -oN myscan.nmap`。 为便于描述的简化，本章使用类似于`myscan.xml`的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。\n\n在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令**nmap -oX myscan.xml target**将 输出XML至`myscan.xml`，并在stdout 上打印相同的交互式结果，而此时`-oX`选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令**nmap -oX - target**只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。\n\n与其它Nmap参数不同，日志文件选项的空格(如`-oX`)和 文件名或连字符是必需的。如果省略了标记，例如`-oG-`或 `-oXscan.xml`，Nmap的向后兼容特点将建立 *标准格式*的输出文件，相应的文件名为`G-`和 `Xscan.xml`。\n\nNmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项 如下所述。\n\n**Nmap输出格式**\n\n- `-oN <filespec>` (标准输出)\n\n  要求将`标准输出`直接写入指定 的文件。如上所述，这个格式与`交互式输出` 略有不同。\n\n- `-oX <filespec>` (XML输出)\n\n  要求`XML输出`直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在 https://nmap.org/data/nmap.dtd获取。XML提供了可供软件解析的稳定格式输出，主要的计算机 语言都提供了免费的XML解析器，如C/C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的[Nmap::Scanner](http://sourceforge.net/projects/nmap-scanner/) 和[Nmap::Parser](http://www.nmapparser.com/)。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。XML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于`nmap.xsl`文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，`--stylesheet` 选项可用于建立可移植的XML文件。\n\n- `-oS <filespec>` (ScRipT KIdd|3 oUTpuT)\n\n  脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 'l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。\n\n- `-oG <filespec>` (Grep输出)\n\n  这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。Grep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有`主机`，`端口`， `协议`，`忽略状态`， `操作系统`，`序列号`， `IPID`和`状态`。这些域中最重要的是`Ports`，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由/分隔。这些子域有：`端口号`， `状态`，`协议`， `拥有者`，`服务`， `SunRPCinfo`和`版本信息`。对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可 查阅http://www.unspecific.com/nmap-oG-output。\n\n- `-oA <basename>` (输出至所有格式)\n\n  为使用方便，利用`-oA*<basename>*`选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 *<basename>*.nmap，*<basename>*.xml和 *<basename>*.gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用`~/nmaplogs/foocorp/`， 在Window中，使用`c:\\hacking\\sco` on Windows。\n\n**细节和调试选项**\n\n- `-v` (提高输出信息的详细度)\n\n  通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。\n\n- `-d [level]` (提高或设置调试级别)\n\n  当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(`-v`)时，可启用命令行参数 (`-d`)，多次使用可提高调试级别。也可在`-d` 后面使用参数设置调试级别。例如，`-d9`设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，`Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 ==> srtt: 14987 rttvar: 14987 to: 100000`。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。\n\n- `--packet-trace` (跟踪发送和接收的报文)\n\n  要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如`-p20-30`。 如果只需进行版本检测，使用`--version-trace`。\n\n- `--iflist` (列举接口和路由)\n\n  输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。\n\n**其它输出选项**\n\n- `--append-output` (在输出文件中添加)\n\n  当使用文件作为输出格式，如`-oX`或`-oN`， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用`--append-output`选项。所有指 定的输出文件都被添加。但对于XML(`-oX`)扫描输出 文件无效，无法正常解析，需要手工修改。\n\n- `--resume <filename>` (继续中断的扫描)\n\n  一些扩展的Nmap运行需要很长的时间 -- 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下**ctrl-C** 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (`-oN`)或Grep扫描(`-oG`)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 `--resume`并说明标准/Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如**nmap --resume <logfilename>**。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。\n\n- `--stylesheet <path or URL>` (设置XSL样式表，转换XML输出)\n\n  Nmap提从了XSL样式表`nmap.xsl`，用于查看 或转换XML输出至HTML。XML输出包含了一个`xml-stylesheet`， 直接指向`nmap.xml`文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找`nmap.xsl`文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 `--stylesheet`的参数，必段指明完整的路 径或URL，常见的调用方式是`--stylesheet https://nmap.org/data/nmap.xsl`。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和`nmap.xsl`) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。\n\n- `--no-stylesheet` (忽略XML声明的XSL样式表)\n\n  使用该选项禁止Nmap的XML输出关联任何XSL样式表。 `xml-stylesheet`指示被忽略。\n\n# 其他选项\n\n本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。\n\n- `-6` (启用IPv6扫描)\n\n  从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加`-6`选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如`3ffe:7501:4819:2000:210:f3ff:fe03:14d0`。 除“所关注的端口”行的地址部分为IPv6地址。IPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于https://tb.ipv6.btexact.com/。 此外，还有Hurricane Electric，位于http://ipv6tb.he.net/。6to4隧道是 另一种常用的免费方法。\n\n- `-A` (激烈扫描模式选项)\n\n  这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(`-O`) 和版本扫描(`-sV`)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如`-T4`)或细节选项(`-v`)。\n\n- `--datadir <directoryname>` (说明用户Nmap数据文件位置)\n\n  Nmap在运行时从文件中获得特殊的数据，这些文件有 `nmap-service-probes`， `nmap-services`， `nmap-protocols`， `nmap-rpc`， `nmap-mac-prefixes`和 `nmap-os-fingerprints`。Nmap首先 在`--datadir`选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的`~/.nmap` 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如`/usr/local/share/nmap`或`/usr/share/nmap`。 Nmap查找的最后一个位置是当前目录。\n\n- `--send-eth` (使用原以太网帧发送)\n\n  要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。\n\n- `--send-ip` (在原IP层发送)\n\n  要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是`--send-eth`选项的补充。\n\n- `--privileged` (假定用户具有全部权限)\n\n  告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 `--privileged`在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于`--privileged`选项。\n\n- `-V`; `--version` (打印版本信息)\n\n  打印Nmap版本号并退出。\n\n- `-h`; `--help` (打印帮助摘要面)\n\n  打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。\n\n# 运行时交互\n\n*Nmap目前还不具有这个功能，本节内容可能会增加或删除。*\n\n在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，*小写字母增加* 打印量，*大写字母减少*打印量。\n\n- `v` / `V`\n\n  增加 / 减少细节\n\n- `d` / `D`\n\n  提高 / 降低调试级别\n\n- `p` / `P`\n\n  打开/ 养老报文跟踪\n\n- 其它\n\n  打印的信息类似于：Stats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service ScanService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)\n\n\n\n# 实例\n\n下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用*你自己网络* 的地址/域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。\n\n如果是为了测试，`scanme.nmap.org` 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告`解析 指定的主机名/IP地址失败：scanme.nmap.org`。这些免 费扫描要求也适用于`scanme2.nmap.org`、 `scanme3.nmap.org`等等，虽然这些 主机目前还不存在。\n\n**nmap -v scanme.nmap.org**\n\n这个选项扫描主机`scanme.nmap.org`中 所有的保留TCP端口。选项`-v`启用细节模式。\n\n**nmap -sS -O scanme.nmap.org/24**\n\n进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。\n\n**nmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127**\n\n进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。\n\n**nmap -v -iR 100000 -P0 -p 80**\n\n随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用`-P0`禁止对主机列表。\n\n**nmap -P0 -p80 -oX logs/pb-port80scan.xml -oG logs/pb-port80scan.gnmap 216.163.128.20/20**\n\n扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。\n\n**host -l company.com | cut -d -f 4 | nmap -v -iL -**\n\n进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU/Linux -- 其它系统进行区域传输时有不同的命令。\n\n# Bugs\n\n和作者一样，Nmap也不是完美的，但可以通过发送Bug报告甚至编写 补丁使其更加完善。如果Nmap不能满足要求，首先从https://nmap.org/ 升级最新版本。如果总问题仍然存在，需要进行调查以确定问题是否 已经被解决。在http://seclists.org/尝试搜索出错消息或 浏览Nmap-dev档案，以及仔细阅读使用手册。如果问题还是不能解决，发送 Bug报告至`<dev@nmap.org>`。在报告中包含所有 有关问题的信息，以及所使用的Nmap版本、操作系统版本。问题报告以及 Nmap的使用问题发送给dev@nmap.org比直接发送给Gyodor能更好回答。\n\n解决Bug的代码补丁比Bug报告更受欢迎，在https://nmap.org/data/HACKING 可获得建立补丁文件的基本指令。补丁可发送给nmap-dev(建议) 或直接发给Fyodor。\n\n\n\n\n\n\n\n","slug":"Nmap的详细说明","published":1,"updated":"2019-09-26T13:05:12.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mke1sa000gbfgaooo1p1yb","content":"<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><ul>\n<li><p>Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。</p>\n<a id=\"more\"></a>\n</li>\n<li><p>Nmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 <code>open</code>(开放的)，<code>filtered</code>(被过滤的)， <code>closed</code>(关闭的)，或者<code>unfiltered</code>(未被过滤的)。 <code>Open</code>(开放的)意味着目标机器上的应用程序正在该端口监听连接/报文。 <code>filtered</code>(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是<code>open</code>(开放的) 还是 <code>closed</code>(关闭的)。 <code>closed</code>(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 <code>unfiltered</code>(未被过滤的) 如果Nmap报告状态组合 <code>open|filtered</code> 和 <code>closed|filtered</code>时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (<code>-sO</code>)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。</p>\n</li>\n<li><p>除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。</p>\n</li>\n</ul>\n<h1 id=\"选项概要\"><a href=\"#选项概要\" class=\"headerlink\" title=\"选项概要\"></a>选项概要</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nmap 7.80SVN ( https://nmap.org )</span><br><span class=\"line\">Usage: nmap [Scan Type(s)] [Options] &#123;target specification&#125;</span><br><span class=\"line\">TARGET SPECIFICATION:</span><br><span class=\"line\">  Can pass hostnames, IP addresses, networks, etc.</span><br><span class=\"line\">  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254</span><br><span class=\"line\">  -iL &lt;inputfilename&gt;: Input from list of hosts/networks</span><br><span class=\"line\">  -iR &lt;num hosts&gt;: Choose random targets</span><br><span class=\"line\">  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks</span><br><span class=\"line\">  --excludefile &lt;exclude_file&gt;: Exclude list from file</span><br><span class=\"line\">HOST DISCOVERY:</span><br><span class=\"line\">  -sL: List Scan - simply list targets to scan</span><br><span class=\"line\">  -sn: Ping Scan - disable port scan</span><br><span class=\"line\">  -Pn: Treat all hosts as online -- skip host discovery</span><br><span class=\"line\">  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports</span><br><span class=\"line\">  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes</span><br><span class=\"line\">  -PO[protocol list]: IP Protocol Ping</span><br><span class=\"line\">  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]</span><br><span class=\"line\">  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers</span><br><span class=\"line\">  --system-dns: Use OS&apos;s DNS resolver</span><br><span class=\"line\">  --traceroute: Trace hop path to each host</span><br><span class=\"line\">SCAN TECHNIQUES:</span><br><span class=\"line\">  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans</span><br><span class=\"line\">  -sU: UDP Scan</span><br><span class=\"line\">  -sN/sF/sX: TCP Null, FIN, and Xmas scans</span><br><span class=\"line\">  --scanflags &lt;flags&gt;: Customize TCP scan flags</span><br><span class=\"line\">  -sI &lt;zombie host[:probeport]&gt;: Idle scan</span><br><span class=\"line\">  -sY/sZ: SCTP INIT/COOKIE-ECHO scans</span><br><span class=\"line\">  -sO: IP protocol scan</span><br><span class=\"line\">  -b &lt;FTP relay host&gt;: FTP bounce scan</span><br><span class=\"line\">PORT SPECIFICATION AND SCAN ORDER:</span><br><span class=\"line\">  -p &lt;port ranges&gt;: Only scan specified ports</span><br><span class=\"line\">    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9</span><br><span class=\"line\">  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning</span><br><span class=\"line\">  -F: Fast mode - Scan fewer ports than the default scan</span><br><span class=\"line\">  -r: Scan ports consecutively - don&apos;t randomize</span><br><span class=\"line\">  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports</span><br><span class=\"line\">  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;</span><br><span class=\"line\">SERVICE/VERSION DETECTION:</span><br><span class=\"line\">  -sV: Probe open ports to determine service/version info</span><br><span class=\"line\">  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)</span><br><span class=\"line\">  --version-light: Limit to most likely probes (intensity 2)</span><br><span class=\"line\">  --version-all: Try every single probe (intensity 9)</span><br><span class=\"line\">  --version-trace: Show detailed version scan activity (for debugging)</span><br><span class=\"line\">SCRIPT SCAN:</span><br><span class=\"line\">  -sC: equivalent to --script=default</span><br><span class=\"line\">  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of</span><br><span class=\"line\">           directories, script-files or script-categories</span><br><span class=\"line\">  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</span><br><span class=\"line\">  --script-args-file=filename: provide NSE script args in a file</span><br><span class=\"line\">  --script-trace: Show all data sent and received</span><br><span class=\"line\">  --script-updatedb: Update the script database.</span><br><span class=\"line\">  --script-help=&lt;Lua scripts&gt;: Show help about scripts.</span><br><span class=\"line\">           &lt;Lua scripts&gt; is a comma-separated list of script-files or</span><br><span class=\"line\">           script-categories.</span><br><span class=\"line\">OS DETECTION:</span><br><span class=\"line\">  -O: Enable OS detection</span><br><span class=\"line\">  --osscan-limit: Limit OS detection to promising targets</span><br><span class=\"line\">  --osscan-guess: Guess OS more aggressively</span><br><span class=\"line\">TIMING AND PERFORMANCE:</span><br><span class=\"line\">  Options which take &lt;time&gt; are in seconds, or append &apos;ms&apos; (milliseconds),</span><br><span class=\"line\">  &apos;s&apos; (seconds), &apos;m&apos; (minutes), or &apos;h&apos; (hours) to the value (e.g. 30m).</span><br><span class=\"line\">  -T&lt;0-5&gt;: Set timing template (higher is faster)</span><br><span class=\"line\">  --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes</span><br><span class=\"line\">  --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization</span><br><span class=\"line\">  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies</span><br><span class=\"line\">      probe round trip time.</span><br><span class=\"line\">  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.</span><br><span class=\"line\">  --host-timeout &lt;time&gt;: Give up on target after this long</span><br><span class=\"line\">  --scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes</span><br><span class=\"line\">  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second</span><br><span class=\"line\">  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per second</span><br><span class=\"line\">FIREWALL/IDS EVASION AND SPOOFING:</span><br><span class=\"line\">  -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)</span><br><span class=\"line\">  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys</span><br><span class=\"line\">  -S &lt;IP_Address&gt;: Spoof source address</span><br><span class=\"line\">  -e &lt;iface&gt;: Use specified interface</span><br><span class=\"line\">  -g/--source-port &lt;portnum&gt;: Use given port number</span><br><span class=\"line\">  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies</span><br><span class=\"line\">  --data &lt;hex string&gt;: Append a custom payload to sent packets</span><br><span class=\"line\">  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets</span><br><span class=\"line\">  --data-length &lt;num&gt;: Append random data to sent packets</span><br><span class=\"line\">  --ip-options &lt;options&gt;: Send packets with specified ip options</span><br><span class=\"line\">  --ttl &lt;val&gt;: Set IP time-to-live field</span><br><span class=\"line\">  --spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address</span><br><span class=\"line\">  --badsum: Send packets with a bogus TCP/UDP/SCTP checksum</span><br><span class=\"line\">OUTPUT:</span><br><span class=\"line\">  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,</span><br><span class=\"line\">     and Grepable format, respectively, to the given filename.</span><br><span class=\"line\">  -oA &lt;basename&gt;: Output in the three major formats at once</span><br><span class=\"line\">  -v: Increase verbosity level (use -vv or more for greater effect)</span><br><span class=\"line\">  -d: Increase debugging level (use -dd or more for greater effect)</span><br><span class=\"line\">  --reason: Display the reason a port is in a particular state</span><br><span class=\"line\">  --open: Only show open (or possibly open) ports</span><br><span class=\"line\">  --packet-trace: Show all packets sent and received</span><br><span class=\"line\">  --iflist: Print host interfaces and routes (for debugging)</span><br><span class=\"line\">  --append-output: Append to rather than clobber specified output files</span><br><span class=\"line\">  --resume &lt;filename&gt;: Resume an aborted scan</span><br><span class=\"line\">  --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML</span><br><span class=\"line\">  --webxml: Reference stylesheet from Nmap.Org for more portable XML</span><br><span class=\"line\">  --no-stylesheet: Prevent associating of XSL stylesheet w/XML output</span><br><span class=\"line\">MISC:</span><br><span class=\"line\">  -6: Enable IPv6 scanning</span><br><span class=\"line\">  -A: Enable OS detection, version detection, script scanning, and traceroute</span><br><span class=\"line\">  --datadir &lt;dirname&gt;: Specify custom Nmap data file location</span><br><span class=\"line\">  --send-eth/--send-ip: Send using raw ethernet frames or IP packets</span><br><span class=\"line\">  --privileged: Assume that the user is fully privileged</span><br><span class=\"line\">  --unprivileged: Assume the user lacks raw socket privileges</span><br><span class=\"line\">  -V: Print version number</span><br><span class=\"line\">  -h: Print this help summary page.</span><br><span class=\"line\">EXAMPLES:</span><br><span class=\"line\">  nmap -v -A scanme.nmap.org</span><br><span class=\"line\">  nmap -v -sn 192.168.0.0/16 10.0.0.0/8</span><br><span class=\"line\">  nmap -v -iR 10000 -Pn -p 80</span><br><span class=\"line\">SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"目标说明\"><a href=\"#目标说明\" class=\"headerlink\" title=\"目标说明\"></a>目标说明</h1><p>除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。</p>\n<p>有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR<code>无类别域间路由，Classless Inter-Domain Routing</code>(是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP<code>Internet Service Provider</code>分配给客户。CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet<a href=\"https://baike.baidu.com/item/路由器/108294\" target=\"_blank\" rel=\"noopener\">路由器</a>的负担)风格的地址。您可以附加 一个/*<numbit><em>在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 *<numbit></numbit></em>相同比特的所有IP地址或主机。 例如，192.168.10.0/24将会扫描192.168.10.0 (二进制格式: <code>11000000 10101000 00001010 00000000</code>)和192.168.10.255 (二进制格式: <code>11000000 10101000 00001010 11111111</code>)之间的256台主机。 192.168.10.40/24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org/16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是/1， 这将会扫描半个互联网。最大值是/32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。</numbit></p>\n<p>CIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0/16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。</p>\n<p>IPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。</p>\n<p>Nmap命令行接受多个主机说明，它们不必是相同类型。命令<strong>nmap scanme.nmap.org 192.168.0.0/8 10.0.0，1，3-7.0-255</strong>将和您预期的一样执行。</p>\n<p>虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：</p>\n<ul>\n<li><p><code>-iL &lt;inputfilename&gt;</code> (从列表中输入)</p>\n<p>从 *<inputfilename><em>中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您</em>不是*使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用<code>-iL</code> 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(<code>-</code>)作为文件名。</inputfilename></p>\n</li>\n<li><p><code>-iR &lt;hostnum&gt;</code> (随机选择目标)</p>\n<p>对于互联网范围内的调查和研究， 您也许想随机地选择目标。 *<hostnum>* 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 <code>0</code> 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令<strong>nmap -sS -PS80 -iR 0 -p 80</strong>随机地找一些网站浏览。</hostnum></p>\n</li>\n<li><p><code>--exclude &lt;host1[，host2][，host3]，...&gt;</code> (排除主机/网络)</p>\n<p>如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。</p>\n</li>\n<li><p><code>--excludefile &lt;excludefile&gt;</code> (排除文件中的列表)</p>\n<p>这和<code>--exclude</code> 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 *<excludefile>*提供的，而不是在命令行上输入的。</excludefile></p>\n</li>\n</ul>\n<h1 id=\"主机发现\"><a href=\"#主机发现\" class=\"headerlink\" title=\"主机发现\"></a>主机发现</h1><p>任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。</p>\n<p>由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(<code>-sL</code>)或者 通过关闭ping (<code>-P0</code>)跳过ping的步骤，也可以使用多个端口把TCP SYN/ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0/8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。</p>\n<p>如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用<code>connect()</code>系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用<code>-PA -PE</code>选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。</p>\n<p><code>-P*</code>选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口/标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 <code>-P*</code>选项，ARP发现(<code>-PR</code>)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。</p>\n<p>下列选项控制主机发现。</p>\n<ul>\n<li><p><code>-sL</code> (列表扫描)</p>\n<p>列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， <code>fw.chi.playboy.com</code>是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 <code>-P0</code>选项的介绍。</p>\n</li>\n<li><p><code>-sP</code> (Ping扫描)</p>\n<p>该选项告诉Nmap<em>仅仅</em> 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。<code>-sP</code>选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用<code>connect()</code>系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(<code>-PR</code>)， ，除非使用了<code>--send-ip</code>选项。 <code>-sP</code>选项可以和除<code>-P0</code>)之外的任何发现探测类型<code>-P*</code> 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。</p>\n</li>\n<li><p><code>-P0</code> (无ping)</p>\n<p>该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用<code>-P0</code>禁止 主机发现会使Nmap对<em>每一个</em>指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(/16)， 所有 65,536 个IP地址都会被扫描。 <code>-P0</code>的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。</p>\n</li>\n<li><p><code>-PS [portlist]</code> (TCP SYN Ping)</p>\n<p>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变<code>nmap.h</code>) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 <code>-PS22，23，25，80，113，1050，35000</code>)， 在这种情况下，每个端口会被并发地扫描。SYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN/ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN/ACK感到很意外。Nmap并不关心端口开放还是关闭。 无论RST还是SYN/ACK响应都告诉Nmap该主机正在运行。在UNIX机器上，通常只有特权用户 <code>root</code> 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN/ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。</p>\n</li>\n<li><p><code>-PA [portlist]</code> (TCP ACK Ping)</p>\n<p>TCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。<code>-PA</code>选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙/路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter/iptables 防火墙软件提供方便的 <code>--syn</code>选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (<code>-PS</code>) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter/iptables 通过 <code>--state</code>选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 <code>-PS</code>又指定<code>-PA</code>来即发送SYN又发送ACK。</p>\n</li>\n<li><p><code>-PU [portlist]</code> (UDP Ping)</p>\n<p>还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了<code>--data-length</code> UDP报文到给定的端口。端口列表的格式和前面讨论过的<code>-PS</code>和<code>-PA</code>选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变<code>nmap.h</code>文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。</p>\n</li>\n<li><p><code>-PE</code>; <code>-PP</code>; <code>-PM</code> (ICMP Ping Types)</p>\n<p>除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见<a href=\"http://www.rfc-editor.org/rfc/rfc1122.txt\" target=\"_blank\" rel=\"noopener\">RFC 1122</a>。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用<code>-PE</code>选项打开该回声请求功能。虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 (<a href=\"http://www.rfc-editor.org/rfc/rfc792.txt\" target=\"_blank\" rel=\"noopener\">RFC 792</a>)还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用<code>-PP</code>和<code>-PM</code>选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。</p>\n</li>\n<li><p><code>-PR</code> (ARP Ping)</p>\n<p>最常见的Nmap使用场景之一是扫描一个以太局域网。 在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件 地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。 当它收到响应时， Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。 即使指定了不同的ping类型(如 <code>-PI</code>或者 <code>-PS</code>) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 <code>--send-ip</code>。</p>\n</li>\n<li><p><code>-n</code> (不用域名解析)</p>\n<p>告诉Nmap <em>永不</em>对它发现的活动IP地址进行反向域名解析。 既然DNS一般比较慢，这可以让事情更快些。</p>\n</li>\n<li><p><code>-R</code> (为所有目标解析域名)</p>\n<p>告诉Nmap <em>永远</em> 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。</p>\n</li>\n<li><p><code>--system-dns</code> (使用系统域名解析器)</p>\n<p>默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug–如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。</p>\n</li>\n</ul>\n<h1 id=\"端口扫描基础\"><a href=\"#端口扫描基础\" class=\"headerlink\" title=\"端口扫描基础\"></a>端口扫描基础</h1><p>虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 <strong>nmap<target></target></strong>这个简单的命令扫描主机*<target>*上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: <code>open</code>(开放的)， <code>closed</code>(关闭的)，<code>filtered</code>(被过滤的)， <code>unfiltered</code>(未被过滤的)， <code>open|filtered(开放或者被过滤的)</code>，或者 <code>closed|filtered(关闭或者被过滤的)</code>。</target></p>\n<p>这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135/tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 <code>filtered</code>(被过滤的)。</p>\n<p><strong>Nmap所识别的6个端口状态。</strong></p>\n<ul>\n<li><p>open(开放的)</p>\n<p>应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。</p>\n</li>\n<li><p>closed(关闭的)</p>\n<p>关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。</p>\n</li>\n<li><p>filtered(被过滤的)</p>\n<p>由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。</p>\n</li>\n<li><p>unfiltered(未被过滤的)</p>\n<p>未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。</p>\n</li>\n<li><p>open|filtered(开放或者被过滤的)</p>\n<p>当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。</p>\n</li>\n<li><p>closed|filtered(关闭或者被过滤的)</p>\n<p>该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。</p>\n</li>\n</ul>\n<h1 id=\"端口扫描技术\"><a href=\"#端口扫描技术\" class=\"headerlink\" title=\"端口扫描技术\"></a>端口扫描技术</h1><p>作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。</p>\n<p>大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。</p>\n<p>虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。</p>\n<p>这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(<code>-sU</code>)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是<code>-s*&lt;C&gt;*</code>， 其中*<c>* 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(<code>-b</code>)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。</c></p>\n<ul>\n<li><p><code>-sS</code> (TCP SYN扫描)</p>\n<p>SYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin/Null/Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分<code>open</code>(开放的)， <code>closed</code>(关闭的)，和<code>filtered</code>(被过滤的) 状态它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</p>\n</li>\n<li><p><code>-sT</code> (TCP connect()扫描)</p>\n<p>当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建<code>connect()</code> 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 <code>connect()</code>调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。</p>\n</li>\n<li><p><code>-sU</code> (UDP扫描)</p>\n<p>虽然互联网上很多流行的服务运行在TCP 协议上，<a href=\"http://www.rfc-editor.org/rfc/rfc768.txt\" target=\"_blank\" rel=\"noopener\">UDP</a>服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161/162，和67/68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。UDP扫描用<code>-sU</code>选项激活。它可以和TCP扫描如 SYN扫描 (<code>-sS</code>)结合使用来同时检查两种协议。UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是<code>closed</code>(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是<code>filtered</code>(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是<code>open</code>(开放的)。 如果几次重试后还没有响应，该端口就被认为是 <code>open|filtered</code>(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(<code>-sV</code>)帮助区分真正的开放端口和被过滤的端口。UDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见<code>net/ipv4/icmp。c</code>)。Nmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用<code>--host-timeout</code>跳过慢速的 主机。</p>\n</li>\n<li><p><code>-sN</code>; <code>-sF</code>; <code>-sX</code> (TCP Null，FIN，and Xmas扫描)</p>\n<p>这三种扫描类型 (甚至用下一节描述的 <code>--scanflags</code> 选项的更多类型) 在<a href=\"http://www.rfc-editor.org/rfc/rfc793.txt\" target=\"_blank\" rel=\"noopener\">TCP RFC</a> 中发掘了一个微妙的方法来区分<code>open</code>(开放的)和 <code>closed</code>(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的…. 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：Null扫描 (<code>-sN</code>)不设置任何标志位(tcp标志头是0)FIN扫描 (<code>-sF</code>)只设置TCP FIN标志位。Xmas扫描 (<code>-sX</code>)设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是<code>closed</code>(关闭的)，而没有响应则意味着 端口是<code>open|filtered(开放或者被过滤的)</code>。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 <code>被过滤的</code>。这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 – 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为<code>closed</code>(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS/400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别<code>open</code>(开放的)端口和一些特定的<code>filtered</code>(被过滤的)端口，从而返回 <code>open|filtered(开放或者被过滤的)</code>。</p>\n</li>\n<li><p><code>-sA</code> (TCP ACK扫描)</p>\n<p>这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定<code>open</code>(开放的)或者 <code>open|filtered(开放或者过滤的)</code>)端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。ACK扫描探测报文只设置ACK标志位(除非您使用 <code>--scanflags</code>)。当扫描未被过滤的系统时， <code>open</code>(开放的)和<code>closed</code>(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 <code>unfiltered</code>(未被过滤的)，意思是 ACK报文不能到达，但至于它们是<code>open</code>(开放的)或者 <code>closed</code>(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 <code>filtered</code>(被过滤的)。</p>\n</li>\n<li><p><code>-sW</code> (TCP窗口扫描)</p>\n<p>除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印<code>unfiltered</code>， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 <code>unfiltered</code>， 而是根据TCP窗口值是正数还是0，分别把端口标记为<code>open</code>或者 <code>closed</code>该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口<code>closed</code>。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 <code>closed</code>，而一些常见的端口 (如 22， 25，53) 是 <code>filtered</code>，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。</p>\n</li>\n<li><p><code>-sM</code> (TCP Maimon扫描)</p>\n<p>Maimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN/ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。</p>\n</li>\n<li><p><code>--scanflags</code> (定制的TCP扫描)</p>\n<p>真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 <code>--scanflags</code>选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！<code>--scanflags</code>选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是<code>URG</code>， <code>ACK</code>，<code>PSH</code>，<code>RST</code>，<code>SYN</code>，and <code>FIN</code>的任何组合就行。例如，<code>--scanflags URGACKPSHRSTSYNFIN</code>设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。除了设置需要的标志位，您也可以设置 TCP扫描类型(如<code>-sA</code>或者<code>-sF</code>)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 <code>filtered</code>端口，而FIN扫描则认为是 <code>open|filtered</code>。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。</p>\n</li>\n<li><p><code>-sI &lt;zombie host[:probeport]&gt;</code> (Idlescan)</p>\n<p>这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在<a href=\"https://nmap.org/book/idlescan.html。除了极端隐蔽(由于它不从真实IP地址发送任何报文)，\" target=\"_blank\" rel=\"noopener\">https://nmap.org/book/idlescan.html。除了极端隐蔽(由于它不从真实IP地址发送任何报文)，</a> 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表<em>从zombie 主机的角度。</em>显示开放的端口。 因此您可以尝试用您认为(通过路由器/包过滤规则)可能被信任的 zombies扫描目标。如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。</p>\n</li>\n<li><p><code>-sO</code> (IP协议扫描)</p>\n<p>IP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 <code>-p</code>选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP <em>协议</em>不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为<code>open</code>。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 <code>closed</code>。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 <code>filtered</code>(虽然同时他们证明ICMP是 <code>open</code> )。如果重试之后仍没有收到响应， 该协议就被标记为<code>open|filtered</code></p>\n</li>\n<li><p><code>-b &lt;ftp relay host&gt;</code> (FTP弹跳扫描)</p>\n<p>FTP协议的一个有趣特征(<a href=\"http://www.rfc-editor.org/rfc/rfc959.txt\" target=\"_blank\" rel=\"noopener\">RFC 959</a>) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用<code>-b</code>选项支持ftp弹跳扫描。参数格式是 *<username><em>:</em><password><em>@</em><server><em>:</em><port><em>。 *<server></server></em> 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略*<username><em>:</em><password><em>， 如果服务器上开放了匿名用户(user:<code>anonymous</code> password:<code>-wwwuser@</code>)。 端口号(以及前面的冒号) 也可以省略，如果</em><server>*使用默认的FTP端口(21)。当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。</server></password></username></port></server></password></username></p>\n</li>\n</ul>\n<h1 id=\"端口说明和扫描顺序\"><a href=\"#端口说明和扫描顺序\" class=\"headerlink\" title=\"端口说明和扫描顺序\"></a>端口说明和扫描顺序</h1><p>除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及<code>nmap-services</code> 文件中列出的更高的端口在扫描。</p>\n<ul>\n<li><p><code>-p &lt;port ranges&gt;</code> (只扫描指定的端口)</p>\n<p>该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及/或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 <code>-p-</code>从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(<code>-sO</code>)，该选项指定您希望扫描的协议号 (0-255)。当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上<code>T:</code> 或者<code>U:</code>指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 <code>-p U:53，111，137，T:21-25，80，139，8080</code> 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 <code>-sU</code> ，以及至少一个TCP扫描类型(如 <code>-sS</code>，<code>-sF</code>，或者 <code>-sT</code>)。如果没有给定协议限定符， 端口号会被加到所有协议列表。</p>\n</li>\n<li><p><code>-F</code> (快速 (有限的端口) 扫描)</p>\n<p>在nmap的<code>nmap-services</code> 文件中(对于<code>-sO</code>，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用<code>--datadir</code>选项指定您自己的 小小的<code>nmap-services</code>文件 ，差别会很惊人。</p>\n</li>\n<li><p><code>-r</code> (不要按随机顺序扫描端口)</p>\n<p>默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定<code>-r</code>来顺序端口扫描。</p>\n</li>\n</ul>\n<h1 id=\"服务和版本探测\"><a href=\"#服务和版本探测\" class=\"headerlink\" title=\"服务和版本探测\"></a>服务和版本探测</h1><p>把Nmap指向一个远程机器，它可能告诉您 端口25/tcp，80/tcp，和53/udp是开放的。使用包含大约2,200个著名的服务的 <code>nmap-services</code>数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 – 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。</p>\n<p>即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。</p>\n<p>在用某种其它类型的扫描方法发现TCP 和/或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 <code>nmap-service-probes</code> 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (<code>-sR</code>)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为<code>open|filtered</code>。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 <code>open|filtered</code> TCP端口用同样的方法对待。 注意Nmap <code>-A</code>选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在 <a href=\"https://nmap.org/vscan/。\" target=\"_blank\" rel=\"noopener\">https://nmap.org/vscan/。</a></p>\n<p>当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。</p>\n<p>用下列的选项打开和控制版本探测。</p>\n<ul>\n<li><p><code>-sV</code> (版本探测)</p>\n<p>打开版本探测。 您也可以用<code>-A</code>同时打开操作系统探测和版本探测。</p>\n</li>\n<li><p><code>--allports</code> (不为版本探测排除任何端口)</p>\n<p>默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除<code>nmap-service-probes</code> 中的<code>Exclude</code>指示符改变， 您也可以不理会任何<code>Exclude</code>指示符，指定<code>--allports</code>扫描所有端口</p>\n</li>\n<li><p><code>--version-intensity &lt;intensity&gt;</code> (设置 版本扫描强度)</p>\n<p>当进行版本扫描(<code>-sV</code>)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过<code>nmap-service-probes</code> <code>ports</code>指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。</p>\n</li>\n<li><p><code>--version-light</code> (打开轻量级模式)</p>\n<p>这是 <code>--version-intensity 2</code>的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。</p>\n</li>\n<li><p><code>--version-all</code> (尝试每个探测)</p>\n<p><code>--version-intensity 9</code>的别名， 保证对每个端口尝试每个探测报文。</p>\n</li>\n<li><p><code>--version-trace</code> (跟踪版本扫描活动)</p>\n<p>这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用<code>--packet-trace</code>所得到的信息的子集。</p>\n</li>\n<li><p><code>-sR</code> (RPC扫描)</p>\n<p>这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP/UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和<strong>rpcinfo -p</strong>一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(<code>-sV</code>)的一部分自动打开。 由于版本探测包括它并且全面得多，<code>-sR</code>很少被需要。</p>\n</li>\n</ul>\n<h1 id=\"操作系统探测\"><a href=\"#操作系统探测\" class=\"headerlink\" title=\"操作系统探测\"></a>操作系统探测</h1><p>Nmap最著名的功能之一是用TCP/IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库<code>nmap-os-fingerprints</code>中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。</p>\n<p>如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。</p>\n<p>操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(<code>-v</code>)下只以 普通的方式输出，如果同时使用<code>-O</code>，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。</p>\n<p><a href=\"https://nmap.org/book/osdetect.html\" target=\"_blank\" rel=\"noopener\">https://nmap.org/book/osdetect.html</a> 文档使用多种语言描述了版本检测的方式、使用和定制。</p>\n<p>采用下列选项启用和控制操作系统检测:</p>\n<ul>\n<li><p><code>-O</code> (启用操作系统检测)</p>\n<p>也可以使用<code>-A</code>来同时启用操作系统检测和版本检测。</p>\n</li>\n<li><p><code>--osscan-limit</code> (针对指定的目标进行操作系统检测)</p>\n<p>如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用<code>-P0</code>扫描多个主机时。这个选项仅在使用 <code>-O</code>或<code>-A</code> 进行操作系统检测时起作用。</p>\n</li>\n<li><p><code>--osscan-guess</code>; <code>--fuzzy</code> (推测操作系统检测结果)</p>\n<p>当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。</p>\n</li>\n</ul>\n<h1 id=\"时间和性能\"><a href=\"#时间和性能\" class=\"headerlink\" title=\"时间和性能\"></a>时间和性能</h1><p>Nmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(<strong>nmap <hostname></hostname></strong>)需要1/5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。</p>\n<p>改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。</p>\n<ul>\n<li><p><code>--min-hostgroup &lt;milliseconds&gt;</code>; <code>--max-hostgroup &lt;milliseconds&gt;</code> (调整并行扫描组的大小)</p>\n<p>Nmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。<code>--max-hostgroup</code>选项用于说明使用最大的组，Nmap不 会超出这个大小。<code>--min-hostgroup</code>选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。</p>\n</li>\n<li><p><code>--min-parallelism &lt;milliseconds&gt;</code>; <code>--max-parallelism &lt;milliseconds&gt;</code> (调整探测报文的并行度)</p>\n<p>这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。最常见的应用是<code>--min-parallelism</code>值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。<code>--max-parallelism</code>选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择<code>--scan-delay</code>同时使用非常有用，虽然 这个选项本身的用途已经很好。</p>\n</li>\n<li><p><code>--min-rtt-timeout &lt;milliseconds&gt;</code>， <code>--max-rtt-timeout &lt;milliseconds&gt;</code>， <code>--initial-rtt-timeout &lt;milliseconds&gt;</code> (调整探测报文超时)</p>\n<p>Nmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。这些选项以毫秒为单位，采用小的<code>--max-rtt-timeout</code>值，使 <code>--initial-rtt-timeout</code>值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(<code>-P0</code>)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。如果所有的主机都在本地网络，对于<code>--max-rtt-timeout</code>值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 <code>--initial-rtt-timeout</code>设成这个时间的2倍，<code>--max-rtt-timeout</code> 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。<code>--min-rtt-timeout</code>这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。</p>\n</li>\n<li><p><code>--host-timeout &lt;milliseconds&gt;</code> (放弃低速目标主机)</p>\n<p>由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要<em>很长</em>的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 <code>--host-timeout</code>选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。</p>\n</li>\n<li><p><code>--scan-delay &lt;milliseconds&gt;</code>; <code>--max-scan-delay &lt;milliseconds&gt;</code> (调整探测报文的时间间隔)</p>\n<p>这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒 只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。<code>--scan-delay</code> 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。<code>--scan-delay</code>的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS/IPS)。</p>\n</li>\n<li><p><code>-T &lt;Paranoid|Sneaky|Polite|Normal|Aggressive|Insane&gt;</code> (设置时间模板)</p>\n<p>上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用<code>-T</code>选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此<code>-T3</code> 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，<code>-T4</code> 针对TCP端口禁止动态扫描延迟超过10ms，<code>-T5</code>对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 <code>-T4</code>，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。如果用于有足够的带宽或以太网连接，仍然建议使用<code>-T4</code>选项。 有些用户喜欢<code>-T5</code>选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用<code>-T2</code>选项。他们并没意识到<code>-T Polite</code>选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(<code>-T3</code>)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。虽然<code>-T0</code>和<code>-T1</code>选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的<code>-T0</code>和<code>-T1</code>选项。<code>T0</code>选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。<code>T1</code>和<code>T2</code>选项比较类似， 探测报文间隔分别为15秒和0.4秒。<code>T3</code>是Nmap的默认选项，包含了并行扫描。 <code>T4</code>选项与 <code>--max-rtt-timeout 1250 --initial-rtt-timeout 500</code> 等价，最大TCP扫描延迟为10ms。<code>T5</code>等价于 <code>--max-rtt-timeout 300 --min-rtt-timeout 50 --initial-rtt-timeout 250 --host-timeout 900000</code>，最大TCP扫描延迟为5ms。</p>\n</li>\n</ul>\n<h1 id=\"防火墙-IDS躲避和哄骗\"><a href=\"#防火墙-IDS躲避和哄骗\" class=\"headerlink\" title=\"防火墙/IDS躲避和哄骗\"></a>防火墙/IDS躲避和哄骗</h1><p>很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。</p>\n<p>类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。</p>\n<p>除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵<em>预防</em>系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。</p>\n<p>有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。</p>\n<p>Nmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。</p>\n<ul>\n<li><p><code>-f</code> (报文分段); <code>--mtu</code> (使用指定的MTU)</p>\n<p><code>-f</code>选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用<code>-f</code>可使用 16字节的分段(减少分段数量)。使用<code>--mtu</code>选项可 以自定义偏移的大小，使用时不需要<code>-f</code>，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用<code>--send-eth</code>选项以避开IP层而直接 发送原始的以太网帧。</p>\n</li>\n<li><p><code>-D &lt;decoy1 [，decoy2][，ME]，...&gt;</code> (使用诱饵隐蔽扫描)</p>\n<p>为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 <code>ME</code>选项说明。如果在第6个位置或 更后的位置使用<code>ME</code>选项，一些常用 端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用<code>ME</code>选项，Nmap 将真实IP放在一个随机的位置注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(<code>-O</code>)。在进行版 本检测或TCP连接扫描时，诱饵无效。使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。</p>\n</li>\n<li><p><code>-S &lt;IP_Address&gt;</code> (源地址哄骗)</p>\n<p>在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用<code>-S</code>选项并说明所需发送包的接口IP地址。这个标志的另一个用处是哄骗性的扫描，使得目标认为是<em>另 一个地址</em>在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ <code>-e</code>选项常在这种情况下使用，也可采用<code>-P0</code>选项。</p>\n</li>\n<li><p><code>-e &lt;interface&gt;</code> (使用指定的接口)</p>\n<p>告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。</p>\n</li>\n<li><p><code>--source-port &lt;portnumber&gt;;</code> <code>-g &lt;portnumber&gt;</code> (源端口哄骗)</p>\n<p>仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。Nmap提供了<code>-g</code>和<code>--source-port</code>选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略<code>--source-port</code>选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。</p>\n</li>\n<li><p><code>--data-length &lt;number&gt;</code> (发送报文时 附加随机数据)</p>\n<p>正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(<code>-O</code>)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。</p>\n</li>\n<li><p><code>--ttl &lt;value&gt;</code> (设置IP time-to-live域)</p>\n<p>设置IPv4报文的time-to-live域为指定的值。</p>\n</li>\n<li><p><code>--randomize-hosts</code> (对目标主机的顺序随机排列)</p>\n<p>告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大<code>nmap.h</code>文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (<code>-sL -n -oN*&lt;filename&gt;*</code>)，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用<code>-iL</code>提供给Nmap。</p>\n</li>\n<li><p><code>--spoof-mac &lt;mac address，prefix，or vendor name&gt;</code> (MAC地址哄骗)</p>\n<p>要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 <code>--send-eth</code>选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过<code>nmap-mac-prefixes</code>查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的<code>--spoof-mac</code>参数有， <code>Apple</code>， <code>0</code>，<code>01:02:03:04:05:06</code>， <code>deadbeefcafe</code>，<code>0020F2</code>， 和<code>Cisco</code>.</p>\n</li>\n</ul>\n<h1 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h1><p>任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和 易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些 方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理 的XML格式。</p>\n<p>除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。</p>\n<p>Nmap提供5种不同的输出格式。默认的方式是<code>interactive output</code>， 发送给标准输出(stdout)。<code>normal output</code>方式类似于 <code>interactive</code>，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。</p>\n<p>XML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。</p>\n<p>另两种输出类型比较简单，<code>grepable output</code>格式，在一行中包含目标主机最多的信息；<code>sCRiPt KiDDi3 0utPUt</code> 格式，用于考虑自己的用户 |&lt;-r4d。</p>\n<p>交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项<code>-oX myscan.xml -oN myscan.nmap</code>。 为便于描述的简化，本章使用类似于<code>myscan.xml</code>的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。</p>\n<p>在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令<strong>nmap -oX myscan.xml target</strong>将 输出XML至<code>myscan.xml</code>，并在stdout 上打印相同的交互式结果，而此时<code>-oX</code>选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令<strong>nmap -oX - target</strong>只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。</p>\n<p>与其它Nmap参数不同，日志文件选项的空格(如<code>-oX</code>)和 文件名或连字符是必需的。如果省略了标记，例如<code>-oG-</code>或 <code>-oXscan.xml</code>，Nmap的向后兼容特点将建立 <em>标准格式</em>的输出文件，相应的文件名为<code>G-</code>和 <code>Xscan.xml</code>。</p>\n<p>Nmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项 如下所述。</p>\n<p><strong>Nmap输出格式</strong></p>\n<ul>\n<li><p><code>-oN &lt;filespec&gt;</code> (标准输出)</p>\n<p>要求将<code>标准输出</code>直接写入指定 的文件。如上所述，这个格式与<code>交互式输出</code> 略有不同。</p>\n</li>\n<li><p><code>-oX &lt;filespec&gt;</code> (XML输出)</p>\n<p>要求<code>XML输出</code>直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在 <a href=\"https://nmap.org/data/nmap.dtd获取。XML提供了可供软件解析的稳定格式输出，主要的计算机\" target=\"_blank\" rel=\"noopener\">https://nmap.org/data/nmap.dtd获取。XML提供了可供软件解析的稳定格式输出，主要的计算机</a> 语言都提供了免费的XML解析器，如C/C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的<a href=\"http://sourceforge.net/projects/nmap-scanner/\" target=\"_blank\" rel=\"noopener\">Nmap::Scanner</a> 和<a href=\"http://www.nmapparser.com/\" target=\"_blank\" rel=\"noopener\">Nmap::Parser</a>。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。XML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于<code>nmap.xsl</code>文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，<code>--stylesheet</code> 选项可用于建立可移植的XML文件。</p>\n</li>\n<li><p><code>-oS &lt;filespec&gt;</code> (ScRipT KIdd|3 oUTpuT)</p>\n<p>脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 ‘l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。</p>\n</li>\n<li><p><code>-oG &lt;filespec&gt;</code> (Grep输出)</p>\n<p>这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。Grep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有<code>主机</code>，<code>端口</code>， <code>协议</code>，<code>忽略状态</code>， <code>操作系统</code>，<code>序列号</code>， <code>IPID</code>和<code>状态</code>。这些域中最重要的是<code>Ports</code>，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由/分隔。这些子域有：<code>端口号</code>， <code>状态</code>，<code>协议</code>， <code>拥有者</code>，<code>服务</code>， <code>SunRPCinfo</code>和<code>版本信息</code>。对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可 查阅<a href=\"http://www.unspecific.com/nmap-oG-output。\" target=\"_blank\" rel=\"noopener\">http://www.unspecific.com/nmap-oG-output。</a></p>\n</li>\n<li><p><code>-oA &lt;basename&gt;</code> (输出至所有格式)</p>\n<p>为使用方便，利用<code>-oA*&lt;basename&gt;*</code>选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 *<basename><em>.nmap，</em><basename><em>.xml和 *<basename></basename></em>.gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用<code>~/nmaplogs/foocorp/</code>， 在Window中，使用<code>c:\\hacking\\sco</code> on Windows。</basename></basename></p>\n</li>\n</ul>\n<p><strong>细节和调试选项</strong></p>\n<ul>\n<li><p><code>-v</code> (提高输出信息的详细度)</p>\n<p>通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。</p>\n</li>\n<li><p><code>-d [level]</code> (提高或设置调试级别)</p>\n<p>当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(<code>-v</code>)时，可启用命令行参数 (<code>-d</code>)，多次使用可提高调试级别。也可在<code>-d</code> 后面使用参数设置调试级别。例如，<code>-d9</code>设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，<code>Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 ==&gt; srtt: 14987 rttvar: 14987 to: 100000</code>。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。</p>\n</li>\n<li><p><code>--packet-trace</code> (跟踪发送和接收的报文)</p>\n<p>要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如<code>-p20-30</code>。 如果只需进行版本检测，使用<code>--version-trace</code>。</p>\n</li>\n<li><p><code>--iflist</code> (列举接口和路由)</p>\n<p>输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。</p>\n</li>\n</ul>\n<p><strong>其它输出选项</strong></p>\n<ul>\n<li><p><code>--append-output</code> (在输出文件中添加)</p>\n<p>当使用文件作为输出格式，如<code>-oX</code>或<code>-oN</code>， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用<code>--append-output</code>选项。所有指 定的输出文件都被添加。但对于XML(<code>-oX</code>)扫描输出 文件无效，无法正常解析，需要手工修改。</p>\n</li>\n<li><p><code>--resume &lt;filename&gt;</code> (继续中断的扫描)</p>\n<p>一些扩展的Nmap运行需要很长的时间 – 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下<strong>ctrl-C</strong> 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (<code>-oN</code>)或Grep扫描(<code>-oG</code>)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 <code>--resume</code>并说明标准/Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如<strong>nmap –resume <logfilename></logfilename></strong>。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。</p>\n</li>\n<li><p><code>--stylesheet &lt;path or URL&gt;</code> (设置XSL样式表，转换XML输出)</p>\n<p>Nmap提从了XSL样式表<code>nmap.xsl</code>，用于查看 或转换XML输出至HTML。XML输出包含了一个<code>xml-stylesheet</code>， 直接指向<code>nmap.xml</code>文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找<code>nmap.xsl</code>文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 <code>--stylesheet</code>的参数，必段指明完整的路 径或URL，常见的调用方式是<code>--stylesheet https://nmap.org/data/nmap.xsl</code>。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和<code>nmap.xsl</code>) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。</p>\n</li>\n<li><p><code>--no-stylesheet</code> (忽略XML声明的XSL样式表)</p>\n<p>使用该选项禁止Nmap的XML输出关联任何XSL样式表。 <code>xml-stylesheet</code>指示被忽略。</p>\n</li>\n</ul>\n<h1 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h1><p>本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。</p>\n<ul>\n<li><p><code>-6</code> (启用IPv6扫描)</p>\n<p>从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加<code>-6</code>选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如<code>3ffe:7501:4819:2000:210:f3ff:fe03:14d0</code>。 除“所关注的端口”行的地址部分为IPv6地址。IPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于<a href=\"https://tb.ipv6.btexact.com/。\" target=\"_blank\" rel=\"noopener\">https://tb.ipv6.btexact.com/。</a> 此外，还有Hurricane Electric，位于<a href=\"http://ipv6tb.he.net/。6to4隧道是\" target=\"_blank\" rel=\"noopener\">http://ipv6tb.he.net/。6to4隧道是</a> 另一种常用的免费方法。</p>\n</li>\n<li><p><code>-A</code> (激烈扫描模式选项)</p>\n<p>这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(<code>-O</code>) 和版本扫描(<code>-sV</code>)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如<code>-T4</code>)或细节选项(<code>-v</code>)。</p>\n</li>\n<li><p><code>--datadir &lt;directoryname&gt;</code> (说明用户Nmap数据文件位置)</p>\n<p>Nmap在运行时从文件中获得特殊的数据，这些文件有 <code>nmap-service-probes</code>， <code>nmap-services</code>， <code>nmap-protocols</code>， <code>nmap-rpc</code>， <code>nmap-mac-prefixes</code>和 <code>nmap-os-fingerprints</code>。Nmap首先 在<code>--datadir</code>选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的<code>~/.nmap</code> 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如<code>/usr/local/share/nmap</code>或<code>/usr/share/nmap</code>。 Nmap查找的最后一个位置是当前目录。</p>\n</li>\n<li><p><code>--send-eth</code> (使用原以太网帧发送)</p>\n<p>要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。</p>\n</li>\n<li><p><code>--send-ip</code> (在原IP层发送)</p>\n<p>要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是<code>--send-eth</code>选项的补充。</p>\n</li>\n<li><p><code>--privileged</code> (假定用户具有全部权限)</p>\n<p>告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 <code>--privileged</code>在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于<code>--privileged</code>选项。</p>\n</li>\n<li><p><code>-V</code>; <code>--version</code> (打印版本信息)</p>\n<p>打印Nmap版本号并退出。</p>\n</li>\n<li><p><code>-h</code>; <code>--help</code> (打印帮助摘要面)</p>\n<p>打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。</p>\n</li>\n</ul>\n<h1 id=\"运行时交互\"><a href=\"#运行时交互\" class=\"headerlink\" title=\"运行时交互\"></a>运行时交互</h1><p><em>Nmap目前还不具有这个功能，本节内容可能会增加或删除。</em></p>\n<p>在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，<em>小写字母增加</em> 打印量，<em>大写字母减少</em>打印量。</p>\n<ul>\n<li><p><code>v</code> / <code>V</code></p>\n<p>增加 / 减少细节</p>\n</li>\n<li><p><code>d</code> / <code>D</code></p>\n<p>提高 / 降低调试级别</p>\n</li>\n<li><p><code>p</code> / <code>P</code></p>\n<p>打开/ 养老报文跟踪</p>\n</li>\n<li><p>其它</p>\n<p>打印的信息类似于：Stats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service ScanService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)</p>\n</li>\n</ul>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用<em>你自己网络</em> 的地址/域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。</p>\n<p>如果是为了测试，<code>scanme.nmap.org</code> 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告<code>解析 指定的主机名/IP地址失败：scanme.nmap.org</code>。这些免 费扫描要求也适用于<code>scanme2.nmap.org</code>、 <code>scanme3.nmap.org</code>等等，虽然这些 主机目前还不存在。</p>\n<p><strong>nmap -v scanme.nmap.org</strong></p>\n<p>这个选项扫描主机<code>scanme.nmap.org</code>中 所有的保留TCP端口。选项<code>-v</code>启用细节模式。</p>\n<p><strong>nmap -sS -O scanme.nmap.org/24</strong></p>\n<p>进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。</p>\n<p><strong>nmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127</strong></p>\n<p>进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。</p>\n<p><strong>nmap -v -iR 100000 -P0 -p 80</strong></p>\n<p>随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用<code>-P0</code>禁止对主机列表。</p>\n<p><strong>nmap -P0 -p80 -oX logs/pb-port80scan.xml -oG logs/pb-port80scan.gnmap 216.163.128.20/20</strong></p>\n<p>扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。</p>\n<p><strong>host -l company.com | cut -d -f 4 | nmap -v -iL -</strong></p>\n<p>进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU/Linux – 其它系统进行区域传输时有不同的命令。</p>\n<h1 id=\"Bugs\"><a href=\"#Bugs\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h1><p>和作者一样，Nmap也不是完美的，但可以通过发送Bug报告甚至编写 补丁使其更加完善。如果Nmap不能满足要求，首先从<a href=\"https://nmap.org/\" target=\"_blank\" rel=\"noopener\">https://nmap.org/</a> 升级最新版本。如果总问题仍然存在，需要进行调查以确定问题是否 已经被解决。在<a href=\"http://seclists.org/尝试搜索出错消息或\" target=\"_blank\" rel=\"noopener\">http://seclists.org/尝试搜索出错消息或</a> 浏览Nmap-dev档案，以及仔细阅读使用手册。如果问题还是不能解决，发送 Bug报告至<code>&lt;dev@nmap.org&gt;</code>。在报告中包含所有 有关问题的信息，以及所使用的Nmap版本、操作系统版本。问题报告以及 Nmap的使用问题发送给<a href=\"mailto:dev@nmap.org\" target=\"_blank\" rel=\"noopener\">dev@nmap.org</a>比直接发送给Gyodor能更好回答。</p>\n<p>解决Bug的代码补丁比Bug报告更受欢迎，在<a href=\"https://nmap.org/data/HACKING\" target=\"_blank\" rel=\"noopener\">https://nmap.org/data/HACKING</a> 可获得建立补丁文件的基本指令。补丁可发送给nmap-dev(建议) 或直接发给Fyodor。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><ul>\n<li><p>Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。</p>","more":"</li>\n<li><p>Nmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 <code>open</code>(开放的)，<code>filtered</code>(被过滤的)， <code>closed</code>(关闭的)，或者<code>unfiltered</code>(未被过滤的)。 <code>Open</code>(开放的)意味着目标机器上的应用程序正在该端口监听连接/报文。 <code>filtered</code>(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是<code>open</code>(开放的) 还是 <code>closed</code>(关闭的)。 <code>closed</code>(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 <code>unfiltered</code>(未被过滤的) 如果Nmap报告状态组合 <code>open|filtered</code> 和 <code>closed|filtered</code>时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (<code>-sO</code>)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。</p>\n</li>\n<li><p>除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。</p>\n</li>\n</ul>\n<h1 id=\"选项概要\"><a href=\"#选项概要\" class=\"headerlink\" title=\"选项概要\"></a>选项概要</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nmap 7.80SVN ( https://nmap.org )</span><br><span class=\"line\">Usage: nmap [Scan Type(s)] [Options] &#123;target specification&#125;</span><br><span class=\"line\">TARGET SPECIFICATION:</span><br><span class=\"line\">  Can pass hostnames, IP addresses, networks, etc.</span><br><span class=\"line\">  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254</span><br><span class=\"line\">  -iL &lt;inputfilename&gt;: Input from list of hosts/networks</span><br><span class=\"line\">  -iR &lt;num hosts&gt;: Choose random targets</span><br><span class=\"line\">  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks</span><br><span class=\"line\">  --excludefile &lt;exclude_file&gt;: Exclude list from file</span><br><span class=\"line\">HOST DISCOVERY:</span><br><span class=\"line\">  -sL: List Scan - simply list targets to scan</span><br><span class=\"line\">  -sn: Ping Scan - disable port scan</span><br><span class=\"line\">  -Pn: Treat all hosts as online -- skip host discovery</span><br><span class=\"line\">  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports</span><br><span class=\"line\">  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes</span><br><span class=\"line\">  -PO[protocol list]: IP Protocol Ping</span><br><span class=\"line\">  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]</span><br><span class=\"line\">  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers</span><br><span class=\"line\">  --system-dns: Use OS&apos;s DNS resolver</span><br><span class=\"line\">  --traceroute: Trace hop path to each host</span><br><span class=\"line\">SCAN TECHNIQUES:</span><br><span class=\"line\">  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans</span><br><span class=\"line\">  -sU: UDP Scan</span><br><span class=\"line\">  -sN/sF/sX: TCP Null, FIN, and Xmas scans</span><br><span class=\"line\">  --scanflags &lt;flags&gt;: Customize TCP scan flags</span><br><span class=\"line\">  -sI &lt;zombie host[:probeport]&gt;: Idle scan</span><br><span class=\"line\">  -sY/sZ: SCTP INIT/COOKIE-ECHO scans</span><br><span class=\"line\">  -sO: IP protocol scan</span><br><span class=\"line\">  -b &lt;FTP relay host&gt;: FTP bounce scan</span><br><span class=\"line\">PORT SPECIFICATION AND SCAN ORDER:</span><br><span class=\"line\">  -p &lt;port ranges&gt;: Only scan specified ports</span><br><span class=\"line\">    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9</span><br><span class=\"line\">  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning</span><br><span class=\"line\">  -F: Fast mode - Scan fewer ports than the default scan</span><br><span class=\"line\">  -r: Scan ports consecutively - don&apos;t randomize</span><br><span class=\"line\">  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports</span><br><span class=\"line\">  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;</span><br><span class=\"line\">SERVICE/VERSION DETECTION:</span><br><span class=\"line\">  -sV: Probe open ports to determine service/version info</span><br><span class=\"line\">  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)</span><br><span class=\"line\">  --version-light: Limit to most likely probes (intensity 2)</span><br><span class=\"line\">  --version-all: Try every single probe (intensity 9)</span><br><span class=\"line\">  --version-trace: Show detailed version scan activity (for debugging)</span><br><span class=\"line\">SCRIPT SCAN:</span><br><span class=\"line\">  -sC: equivalent to --script=default</span><br><span class=\"line\">  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of</span><br><span class=\"line\">           directories, script-files or script-categories</span><br><span class=\"line\">  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</span><br><span class=\"line\">  --script-args-file=filename: provide NSE script args in a file</span><br><span class=\"line\">  --script-trace: Show all data sent and received</span><br><span class=\"line\">  --script-updatedb: Update the script database.</span><br><span class=\"line\">  --script-help=&lt;Lua scripts&gt;: Show help about scripts.</span><br><span class=\"line\">           &lt;Lua scripts&gt; is a comma-separated list of script-files or</span><br><span class=\"line\">           script-categories.</span><br><span class=\"line\">OS DETECTION:</span><br><span class=\"line\">  -O: Enable OS detection</span><br><span class=\"line\">  --osscan-limit: Limit OS detection to promising targets</span><br><span class=\"line\">  --osscan-guess: Guess OS more aggressively</span><br><span class=\"line\">TIMING AND PERFORMANCE:</span><br><span class=\"line\">  Options which take &lt;time&gt; are in seconds, or append &apos;ms&apos; (milliseconds),</span><br><span class=\"line\">  &apos;s&apos; (seconds), &apos;m&apos; (minutes), or &apos;h&apos; (hours) to the value (e.g. 30m).</span><br><span class=\"line\">  -T&lt;0-5&gt;: Set timing template (higher is faster)</span><br><span class=\"line\">  --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes</span><br><span class=\"line\">  --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization</span><br><span class=\"line\">  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies</span><br><span class=\"line\">      probe round trip time.</span><br><span class=\"line\">  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.</span><br><span class=\"line\">  --host-timeout &lt;time&gt;: Give up on target after this long</span><br><span class=\"line\">  --scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes</span><br><span class=\"line\">  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second</span><br><span class=\"line\">  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per second</span><br><span class=\"line\">FIREWALL/IDS EVASION AND SPOOFING:</span><br><span class=\"line\">  -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)</span><br><span class=\"line\">  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys</span><br><span class=\"line\">  -S &lt;IP_Address&gt;: Spoof source address</span><br><span class=\"line\">  -e &lt;iface&gt;: Use specified interface</span><br><span class=\"line\">  -g/--source-port &lt;portnum&gt;: Use given port number</span><br><span class=\"line\">  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies</span><br><span class=\"line\">  --data &lt;hex string&gt;: Append a custom payload to sent packets</span><br><span class=\"line\">  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets</span><br><span class=\"line\">  --data-length &lt;num&gt;: Append random data to sent packets</span><br><span class=\"line\">  --ip-options &lt;options&gt;: Send packets with specified ip options</span><br><span class=\"line\">  --ttl &lt;val&gt;: Set IP time-to-live field</span><br><span class=\"line\">  --spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address</span><br><span class=\"line\">  --badsum: Send packets with a bogus TCP/UDP/SCTP checksum</span><br><span class=\"line\">OUTPUT:</span><br><span class=\"line\">  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,</span><br><span class=\"line\">     and Grepable format, respectively, to the given filename.</span><br><span class=\"line\">  -oA &lt;basename&gt;: Output in the three major formats at once</span><br><span class=\"line\">  -v: Increase verbosity level (use -vv or more for greater effect)</span><br><span class=\"line\">  -d: Increase debugging level (use -dd or more for greater effect)</span><br><span class=\"line\">  --reason: Display the reason a port is in a particular state</span><br><span class=\"line\">  --open: Only show open (or possibly open) ports</span><br><span class=\"line\">  --packet-trace: Show all packets sent and received</span><br><span class=\"line\">  --iflist: Print host interfaces and routes (for debugging)</span><br><span class=\"line\">  --append-output: Append to rather than clobber specified output files</span><br><span class=\"line\">  --resume &lt;filename&gt;: Resume an aborted scan</span><br><span class=\"line\">  --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML</span><br><span class=\"line\">  --webxml: Reference stylesheet from Nmap.Org for more portable XML</span><br><span class=\"line\">  --no-stylesheet: Prevent associating of XSL stylesheet w/XML output</span><br><span class=\"line\">MISC:</span><br><span class=\"line\">  -6: Enable IPv6 scanning</span><br><span class=\"line\">  -A: Enable OS detection, version detection, script scanning, and traceroute</span><br><span class=\"line\">  --datadir &lt;dirname&gt;: Specify custom Nmap data file location</span><br><span class=\"line\">  --send-eth/--send-ip: Send using raw ethernet frames or IP packets</span><br><span class=\"line\">  --privileged: Assume that the user is fully privileged</span><br><span class=\"line\">  --unprivileged: Assume the user lacks raw socket privileges</span><br><span class=\"line\">  -V: Print version number</span><br><span class=\"line\">  -h: Print this help summary page.</span><br><span class=\"line\">EXAMPLES:</span><br><span class=\"line\">  nmap -v -A scanme.nmap.org</span><br><span class=\"line\">  nmap -v -sn 192.168.0.0/16 10.0.0.0/8</span><br><span class=\"line\">  nmap -v -iR 10000 -Pn -p 80</span><br><span class=\"line\">SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"目标说明\"><a href=\"#目标说明\" class=\"headerlink\" title=\"目标说明\"></a>目标说明</h1><p>除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。</p>\n<p>有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR<code>无类别域间路由，Classless Inter-Domain Routing</code>(是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP<code>Internet Service Provider</code>分配给客户。CIDR将路由集中起来，使一个IP地址代表主要骨干提供商服务的几千个IP地址，从而减轻Internet<a href=\"https://baike.baidu.com/item/路由器/108294\" target=\"_blank\" rel=\"noopener\">路由器</a>的负担)风格的地址。您可以附加 一个/*<numbit><em>在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 *<numbit></numbit></em>相同比特的所有IP地址或主机。 例如，192.168.10.0/24将会扫描192.168.10.0 (二进制格式: <code>11000000 10101000 00001010 00000000</code>)和192.168.10.255 (二进制格式: <code>11000000 10101000 00001010 11111111</code>)之间的256台主机。 192.168.10.40/24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org/16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是/1， 这将会扫描半个互联网。最大值是/32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。</numbit></p>\n<p>CIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0/16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。</p>\n<p>IPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。</p>\n<p>Nmap命令行接受多个主机说明，它们不必是相同类型。命令<strong>nmap scanme.nmap.org 192.168.0.0/8 10.0.0，1，3-7.0-255</strong>将和您预期的一样执行。</p>\n<p>虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：</p>\n<ul>\n<li><p><code>-iL &lt;inputfilename&gt;</code> (从列表中输入)</p>\n<p>从 *<inputfilename><em>中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您</em>不是*使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用<code>-iL</code> 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(<code>-</code>)作为文件名。</inputfilename></p>\n</li>\n<li><p><code>-iR &lt;hostnum&gt;</code> (随机选择目标)</p>\n<p>对于互联网范围内的调查和研究， 您也许想随机地选择目标。 *<hostnum>* 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 <code>0</code> 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令<strong>nmap -sS -PS80 -iR 0 -p 80</strong>随机地找一些网站浏览。</hostnum></p>\n</li>\n<li><p><code>--exclude &lt;host1[，host2][，host3]，...&gt;</code> (排除主机/网络)</p>\n<p>如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。</p>\n</li>\n<li><p><code>--excludefile &lt;excludefile&gt;</code> (排除文件中的列表)</p>\n<p>这和<code>--exclude</code> 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 *<excludefile>*提供的，而不是在命令行上输入的。</excludefile></p>\n</li>\n</ul>\n<h1 id=\"主机发现\"><a href=\"#主机发现\" class=\"headerlink\" title=\"主机发现\"></a>主机发现</h1><p>任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图 突破防火墙的封锁。</p>\n<p>由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(<code>-sL</code>)或者 通过关闭ping (<code>-P0</code>)跳过ping的步骤，也可以使用多个端口把TCP SYN/ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0/8尤其普遍。 那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。 主机发现能够找到零星分布于IP地址海洋上的那些机器。</p>\n<p>如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用<code>connect()</code>系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用<code>-PA -PE</code>选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。</p>\n<p><code>-P*</code>选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口/标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 <code>-P*</code>选项，ARP发现(<code>-PR</code>)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。</p>\n<p>下列选项控制主机发现。</p>\n<ul>\n<li><p><code>-sL</code> (列表扫描)</p>\n<p>列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， <code>fw.chi.playboy.com</code>是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 <code>-P0</code>选项的介绍。</p>\n</li>\n<li><p><code>-sP</code> (Ping扫描)</p>\n<p>该选项告诉Nmap<em>仅仅</em> 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。<code>-sP</code>选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用<code>connect()</code>系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(<code>-PR</code>)， ，除非使用了<code>--send-ip</code>选项。 <code>-sP</code>选项可以和除<code>-P0</code>)之外的任何发现探测类型<code>-P*</code> 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。</p>\n</li>\n<li><p><code>-P0</code> (无ping)</p>\n<p>该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用<code>-P0</code>禁止 主机发现会使Nmap对<em>每一个</em>指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(/16)， 所有 65,536 个IP地址都会被扫描。 <code>-P0</code>的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。</p>\n</li>\n<li><p><code>-PS [portlist]</code> (TCP SYN Ping)</p>\n<p>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变<code>nmap.h</code>) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 <code>-PS22，23，25，80，113，1050，35000</code>)， 在这种情况下，每个端口会被并发地扫描。SYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN/ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN/ACK感到很意外。Nmap并不关心端口开放还是关闭。 无论RST还是SYN/ACK响应都告诉Nmap该主机正在运行。在UNIX机器上，通常只有特权用户 <code>root</code> 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN/ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。</p>\n</li>\n<li><p><code>-PA [portlist]</code> (TCP ACK Ping)</p>\n<p>TCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。<code>-PA</code>选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙/路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter/iptables 防火墙软件提供方便的 <code>--syn</code>选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (<code>-PS</code>) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter/iptables 通过 <code>--state</code>选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 <code>-PS</code>又指定<code>-PA</code>来即发送SYN又发送ACK。</p>\n</li>\n<li><p><code>-PU [portlist]</code> (UDP Ping)</p>\n<p>还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了<code>--data-length</code> UDP报文到给定的端口。端口列表的格式和前面讨论过的<code>-PS</code>和<code>-PA</code>选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变<code>nmap.h</code>文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。</p>\n</li>\n<li><p><code>-PE</code>; <code>-PP</code>; <code>-PM</code> (ICMP Ping Types)</p>\n<p>除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见<a href=\"http://www.rfc-editor.org/rfc/rfc1122.txt\" target=\"_blank\" rel=\"noopener\">RFC 1122</a>。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用<code>-PE</code>选项打开该回声请求功能。虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 (<a href=\"http://www.rfc-editor.org/rfc/rfc792.txt\" target=\"_blank\" rel=\"noopener\">RFC 792</a>)还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用<code>-PP</code>和<code>-PM</code>选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。</p>\n</li>\n<li><p><code>-PR</code> (ARP Ping)</p>\n<p>最常见的Nmap使用场景之一是扫描一个以太局域网。 在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件 地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。 当它收到响应时， Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。 即使指定了不同的ping类型(如 <code>-PI</code>或者 <code>-PS</code>) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 <code>--send-ip</code>。</p>\n</li>\n<li><p><code>-n</code> (不用域名解析)</p>\n<p>告诉Nmap <em>永不</em>对它发现的活动IP地址进行反向域名解析。 既然DNS一般比较慢，这可以让事情更快些。</p>\n</li>\n<li><p><code>-R</code> (为所有目标解析域名)</p>\n<p>告诉Nmap <em>永远</em> 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。</p>\n</li>\n<li><p><code>--system-dns</code> (使用系统域名解析器)</p>\n<p>默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug–如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。</p>\n</li>\n</ul>\n<h1 id=\"端口扫描基础\"><a href=\"#端口扫描基础\" class=\"headerlink\" title=\"端口扫描基础\"></a>端口扫描基础</h1><p>虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 <strong>nmap<target></target></strong>这个简单的命令扫描主机*<target>*上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: <code>open</code>(开放的)， <code>closed</code>(关闭的)，<code>filtered</code>(被过滤的)， <code>unfiltered</code>(未被过滤的)， <code>open|filtered(开放或者被过滤的)</code>，或者 <code>closed|filtered(关闭或者被过滤的)</code>。</target></p>\n<p>这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135/tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 <code>filtered</code>(被过滤的)。</p>\n<p><strong>Nmap所识别的6个端口状态。</strong></p>\n<ul>\n<li><p>open(开放的)</p>\n<p>应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。</p>\n</li>\n<li><p>closed(关闭的)</p>\n<p>关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。</p>\n</li>\n<li><p>filtered(被过滤的)</p>\n<p>由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。</p>\n</li>\n<li><p>unfiltered(未被过滤的)</p>\n<p>未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。</p>\n</li>\n<li><p>open|filtered(开放或者被过滤的)</p>\n<p>当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。</p>\n</li>\n<li><p>closed|filtered(关闭或者被过滤的)</p>\n<p>该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。</p>\n</li>\n</ul>\n<h1 id=\"端口扫描技术\"><a href=\"#端口扫描技术\" class=\"headerlink\" title=\"端口扫描技术\"></a>端口扫描技术</h1><p>作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。</p>\n<p>大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。</p>\n<p>虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。</p>\n<p>这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(<code>-sU</code>)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是<code>-s*&lt;C&gt;*</code>， 其中*<c>* 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(<code>-b</code>)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。</c></p>\n<ul>\n<li><p><code>-sS</code> (TCP SYN扫描)</p>\n<p>SYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin/Null/Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分<code>open</code>(开放的)， <code>closed</code>(关闭的)，和<code>filtered</code>(被过滤的) 状态它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</p>\n</li>\n<li><p><code>-sT</code> (TCP connect()扫描)</p>\n<p>当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建<code>connect()</code> 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 <code>connect()</code>调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。</p>\n</li>\n<li><p><code>-sU</code> (UDP扫描)</p>\n<p>虽然互联网上很多流行的服务运行在TCP 协议上，<a href=\"http://www.rfc-editor.org/rfc/rfc768.txt\" target=\"_blank\" rel=\"noopener\">UDP</a>服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161/162，和67/68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。UDP扫描用<code>-sU</code>选项激活。它可以和TCP扫描如 SYN扫描 (<code>-sS</code>)结合使用来同时检查两种协议。UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是<code>closed</code>(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是<code>filtered</code>(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是<code>open</code>(开放的)。 如果几次重试后还没有响应，该端口就被认为是 <code>open|filtered</code>(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(<code>-sV</code>)帮助区分真正的开放端口和被过滤的端口。UDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见<code>net/ipv4/icmp。c</code>)。Nmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用<code>--host-timeout</code>跳过慢速的 主机。</p>\n</li>\n<li><p><code>-sN</code>; <code>-sF</code>; <code>-sX</code> (TCP Null，FIN，and Xmas扫描)</p>\n<p>这三种扫描类型 (甚至用下一节描述的 <code>--scanflags</code> 选项的更多类型) 在<a href=\"http://www.rfc-editor.org/rfc/rfc793.txt\" target=\"_blank\" rel=\"noopener\">TCP RFC</a> 中发掘了一个微妙的方法来区分<code>open</code>(开放的)和 <code>closed</code>(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的…. 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：Null扫描 (<code>-sN</code>)不设置任何标志位(tcp标志头是0)FIN扫描 (<code>-sF</code>)只设置TCP FIN标志位。Xmas扫描 (<code>-sX</code>)设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是<code>closed</code>(关闭的)，而没有响应则意味着 端口是<code>open|filtered(开放或者被过滤的)</code>。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 <code>被过滤的</code>。这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 – 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为<code>closed</code>(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS/400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别<code>open</code>(开放的)端口和一些特定的<code>filtered</code>(被过滤的)端口，从而返回 <code>open|filtered(开放或者被过滤的)</code>。</p>\n</li>\n<li><p><code>-sA</code> (TCP ACK扫描)</p>\n<p>这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定<code>open</code>(开放的)或者 <code>open|filtered(开放或者过滤的)</code>)端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。ACK扫描探测报文只设置ACK标志位(除非您使用 <code>--scanflags</code>)。当扫描未被过滤的系统时， <code>open</code>(开放的)和<code>closed</code>(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 <code>unfiltered</code>(未被过滤的)，意思是 ACK报文不能到达，但至于它们是<code>open</code>(开放的)或者 <code>closed</code>(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 <code>filtered</code>(被过滤的)。</p>\n</li>\n<li><p><code>-sW</code> (TCP窗口扫描)</p>\n<p>除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印<code>unfiltered</code>， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 <code>unfiltered</code>， 而是根据TCP窗口值是正数还是0，分别把端口标记为<code>open</code>或者 <code>closed</code>该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口<code>closed</code>。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 <code>closed</code>，而一些常见的端口 (如 22， 25，53) 是 <code>filtered</code>，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。</p>\n</li>\n<li><p><code>-sM</code> (TCP Maimon扫描)</p>\n<p>Maimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN/ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。</p>\n</li>\n<li><p><code>--scanflags</code> (定制的TCP扫描)</p>\n<p>真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 <code>--scanflags</code>选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！<code>--scanflags</code>选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是<code>URG</code>， <code>ACK</code>，<code>PSH</code>，<code>RST</code>，<code>SYN</code>，and <code>FIN</code>的任何组合就行。例如，<code>--scanflags URGACKPSHRSTSYNFIN</code>设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。除了设置需要的标志位，您也可以设置 TCP扫描类型(如<code>-sA</code>或者<code>-sF</code>)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 <code>filtered</code>端口，而FIN扫描则认为是 <code>open|filtered</code>。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。</p>\n</li>\n<li><p><code>-sI &lt;zombie host[:probeport]&gt;</code> (Idlescan)</p>\n<p>这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在<a href=\"https://nmap.org/book/idlescan.html。除了极端隐蔽(由于它不从真实IP地址发送任何报文)，\" target=\"_blank\" rel=\"noopener\">https://nmap.org/book/idlescan.html。除了极端隐蔽(由于它不从真实IP地址发送任何报文)，</a> 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表<em>从zombie 主机的角度。</em>显示开放的端口。 因此您可以尝试用您认为(通过路由器/包过滤规则)可能被信任的 zombies扫描目标。如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。</p>\n</li>\n<li><p><code>-sO</code> (IP协议扫描)</p>\n<p>IP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 <code>-p</code>选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP <em>协议</em>不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为<code>open</code>。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 <code>closed</code>。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 <code>filtered</code>(虽然同时他们证明ICMP是 <code>open</code> )。如果重试之后仍没有收到响应， 该协议就被标记为<code>open|filtered</code></p>\n</li>\n<li><p><code>-b &lt;ftp relay host&gt;</code> (FTP弹跳扫描)</p>\n<p>FTP协议的一个有趣特征(<a href=\"http://www.rfc-editor.org/rfc/rfc959.txt\" target=\"_blank\" rel=\"noopener\">RFC 959</a>) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用<code>-b</code>选项支持ftp弹跳扫描。参数格式是 *<username><em>:</em><password><em>@</em><server><em>:</em><port><em>。 *<server></server></em> 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略*<username><em>:</em><password><em>， 如果服务器上开放了匿名用户(user:<code>anonymous</code> password:<code>-wwwuser@</code>)。 端口号(以及前面的冒号) 也可以省略，如果</em><server>*使用默认的FTP端口(21)。当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。</server></password></username></port></server></password></username></p>\n</li>\n</ul>\n<h1 id=\"端口说明和扫描顺序\"><a href=\"#端口说明和扫描顺序\" class=\"headerlink\" title=\"端口说明和扫描顺序\"></a>端口说明和扫描顺序</h1><p>除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及<code>nmap-services</code> 文件中列出的更高的端口在扫描。</p>\n<ul>\n<li><p><code>-p &lt;port ranges&gt;</code> (只扫描指定的端口)</p>\n<p>该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及/或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 <code>-p-</code>从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(<code>-sO</code>)，该选项指定您希望扫描的协议号 (0-255)。当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上<code>T:</code> 或者<code>U:</code>指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 <code>-p U:53，111，137，T:21-25，80，139，8080</code> 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 <code>-sU</code> ，以及至少一个TCP扫描类型(如 <code>-sS</code>，<code>-sF</code>，或者 <code>-sT</code>)。如果没有给定协议限定符， 端口号会被加到所有协议列表。</p>\n</li>\n<li><p><code>-F</code> (快速 (有限的端口) 扫描)</p>\n<p>在nmap的<code>nmap-services</code> 文件中(对于<code>-sO</code>，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用<code>--datadir</code>选项指定您自己的 小小的<code>nmap-services</code>文件 ，差别会很惊人。</p>\n</li>\n<li><p><code>-r</code> (不要按随机顺序扫描端口)</p>\n<p>默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定<code>-r</code>来顺序端口扫描。</p>\n</li>\n</ul>\n<h1 id=\"服务和版本探测\"><a href=\"#服务和版本探测\" class=\"headerlink\" title=\"服务和版本探测\"></a>服务和版本探测</h1><p>把Nmap指向一个远程机器，它可能告诉您 端口25/tcp，80/tcp，和53/udp是开放的。使用包含大约2,200个著名的服务的 <code>nmap-services</code>数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 – 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。</p>\n<p>即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。</p>\n<p>在用某种其它类型的扫描方法发现TCP 和/或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 <code>nmap-service-probes</code> 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (<code>-sR</code>)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为<code>open|filtered</code>。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 <code>open|filtered</code> TCP端口用同样的方法对待。 注意Nmap <code>-A</code>选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在 <a href=\"https://nmap.org/vscan/。\" target=\"_blank\" rel=\"noopener\">https://nmap.org/vscan/。</a></p>\n<p>当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。</p>\n<p>用下列的选项打开和控制版本探测。</p>\n<ul>\n<li><p><code>-sV</code> (版本探测)</p>\n<p>打开版本探测。 您也可以用<code>-A</code>同时打开操作系统探测和版本探测。</p>\n</li>\n<li><p><code>--allports</code> (不为版本探测排除任何端口)</p>\n<p>默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除<code>nmap-service-probes</code> 中的<code>Exclude</code>指示符改变， 您也可以不理会任何<code>Exclude</code>指示符，指定<code>--allports</code>扫描所有端口</p>\n</li>\n<li><p><code>--version-intensity &lt;intensity&gt;</code> (设置 版本扫描强度)</p>\n<p>当进行版本扫描(<code>-sV</code>)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过<code>nmap-service-probes</code> <code>ports</code>指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。</p>\n</li>\n<li><p><code>--version-light</code> (打开轻量级模式)</p>\n<p>这是 <code>--version-intensity 2</code>的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。</p>\n</li>\n<li><p><code>--version-all</code> (尝试每个探测)</p>\n<p><code>--version-intensity 9</code>的别名， 保证对每个端口尝试每个探测报文。</p>\n</li>\n<li><p><code>--version-trace</code> (跟踪版本扫描活动)</p>\n<p>这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用<code>--packet-trace</code>所得到的信息的子集。</p>\n</li>\n<li><p><code>-sR</code> (RPC扫描)</p>\n<p>这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP/UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和<strong>rpcinfo -p</strong>一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(<code>-sV</code>)的一部分自动打开。 由于版本探测包括它并且全面得多，<code>-sR</code>很少被需要。</p>\n</li>\n</ul>\n<h1 id=\"操作系统探测\"><a href=\"#操作系统探测\" class=\"headerlink\" title=\"操作系统探测\"></a>操作系统探测</h1><p>Nmap最著名的功能之一是用TCP/IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库<code>nmap-os-fingerprints</code>中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。</p>\n<p>如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。</p>\n<p>操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(<code>-v</code>)下只以 普通的方式输出，如果同时使用<code>-O</code>，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。</p>\n<p><a href=\"https://nmap.org/book/osdetect.html\" target=\"_blank\" rel=\"noopener\">https://nmap.org/book/osdetect.html</a> 文档使用多种语言描述了版本检测的方式、使用和定制。</p>\n<p>采用下列选项启用和控制操作系统检测:</p>\n<ul>\n<li><p><code>-O</code> (启用操作系统检测)</p>\n<p>也可以使用<code>-A</code>来同时启用操作系统检测和版本检测。</p>\n</li>\n<li><p><code>--osscan-limit</code> (针对指定的目标进行操作系统检测)</p>\n<p>如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用<code>-P0</code>扫描多个主机时。这个选项仅在使用 <code>-O</code>或<code>-A</code> 进行操作系统检测时起作用。</p>\n</li>\n<li><p><code>--osscan-guess</code>; <code>--fuzzy</code> (推测操作系统检测结果)</p>\n<p>当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。</p>\n</li>\n</ul>\n<h1 id=\"时间和性能\"><a href=\"#时间和性能\" class=\"headerlink\" title=\"时间和性能\"></a>时间和性能</h1><p>Nmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(<strong>nmap <hostname></hostname></strong>)需要1/5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。</p>\n<p>改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。</p>\n<ul>\n<li><p><code>--min-hostgroup &lt;milliseconds&gt;</code>; <code>--max-hostgroup &lt;milliseconds&gt;</code> (调整并行扫描组的大小)</p>\n<p>Nmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。<code>--max-hostgroup</code>选项用于说明使用最大的组，Nmap不 会超出这个大小。<code>--min-hostgroup</code>选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。</p>\n</li>\n<li><p><code>--min-parallelism &lt;milliseconds&gt;</code>; <code>--max-parallelism &lt;milliseconds&gt;</code> (调整探测报文的并行度)</p>\n<p>这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。最常见的应用是<code>--min-parallelism</code>值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。<code>--max-parallelism</code>选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择<code>--scan-delay</code>同时使用非常有用，虽然 这个选项本身的用途已经很好。</p>\n</li>\n<li><p><code>--min-rtt-timeout &lt;milliseconds&gt;</code>， <code>--max-rtt-timeout &lt;milliseconds&gt;</code>， <code>--initial-rtt-timeout &lt;milliseconds&gt;</code> (调整探测报文超时)</p>\n<p>Nmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。这些选项以毫秒为单位，采用小的<code>--max-rtt-timeout</code>值，使 <code>--initial-rtt-timeout</code>值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(<code>-P0</code>)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。如果所有的主机都在本地网络，对于<code>--max-rtt-timeout</code>值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 <code>--initial-rtt-timeout</code>设成这个时间的2倍，<code>--max-rtt-timeout</code> 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。<code>--min-rtt-timeout</code>这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。</p>\n</li>\n<li><p><code>--host-timeout &lt;milliseconds&gt;</code> (放弃低速目标主机)</p>\n<p>由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要<em>很长</em>的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 <code>--host-timeout</code>选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。</p>\n</li>\n<li><p><code>--scan-delay &lt;milliseconds&gt;</code>; <code>--max-scan-delay &lt;milliseconds&gt;</code> (调整探测报文的时间间隔)</p>\n<p>这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒 只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。<code>--scan-delay</code> 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。<code>--scan-delay</code>的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS/IPS)。</p>\n</li>\n<li><p><code>-T &lt;Paranoid|Sneaky|Polite|Normal|Aggressive|Insane&gt;</code> (设置时间模板)</p>\n<p>上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用<code>-T</code>选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此<code>-T3</code> 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，<code>-T4</code> 针对TCP端口禁止动态扫描延迟超过10ms，<code>-T5</code>对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 <code>-T4</code>，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。如果用于有足够的带宽或以太网连接，仍然建议使用<code>-T4</code>选项。 有些用户喜欢<code>-T5</code>选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用<code>-T2</code>选项。他们并没意识到<code>-T Polite</code>选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(<code>-T3</code>)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。虽然<code>-T0</code>和<code>-T1</code>选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的<code>-T0</code>和<code>-T1</code>选项。<code>T0</code>选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。<code>T1</code>和<code>T2</code>选项比较类似， 探测报文间隔分别为15秒和0.4秒。<code>T3</code>是Nmap的默认选项，包含了并行扫描。 <code>T4</code>选项与 <code>--max-rtt-timeout 1250 --initial-rtt-timeout 500</code> 等价，最大TCP扫描延迟为10ms。<code>T5</code>等价于 <code>--max-rtt-timeout 300 --min-rtt-timeout 50 --initial-rtt-timeout 250 --host-timeout 900000</code>，最大TCP扫描延迟为5ms。</p>\n</li>\n</ul>\n<h1 id=\"防火墙-IDS躲避和哄骗\"><a href=\"#防火墙-IDS躲避和哄骗\" class=\"headerlink\" title=\"防火墙/IDS躲避和哄骗\"></a>防火墙/IDS躲避和哄骗</h1><p>很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。</p>\n<p>类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。</p>\n<p>除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵<em>预防</em>系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。</p>\n<p>有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。</p>\n<p>Nmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。</p>\n<ul>\n<li><p><code>-f</code> (报文分段); <code>--mtu</code> (使用指定的MTU)</p>\n<p><code>-f</code>选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用<code>-f</code>可使用 16字节的分段(减少分段数量)。使用<code>--mtu</code>选项可 以自定义偏移的大小，使用时不需要<code>-f</code>，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用<code>--send-eth</code>选项以避开IP层而直接 发送原始的以太网帧。</p>\n</li>\n<li><p><code>-D &lt;decoy1 [，decoy2][，ME]，...&gt;</code> (使用诱饵隐蔽扫描)</p>\n<p>为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 <code>ME</code>选项说明。如果在第6个位置或 更后的位置使用<code>ME</code>选项，一些常用 端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用<code>ME</code>选项，Nmap 将真实IP放在一个随机的位置注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(<code>-O</code>)。在进行版 本检测或TCP连接扫描时，诱饵无效。使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。</p>\n</li>\n<li><p><code>-S &lt;IP_Address&gt;</code> (源地址哄骗)</p>\n<p>在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用<code>-S</code>选项并说明所需发送包的接口IP地址。这个标志的另一个用处是哄骗性的扫描，使得目标认为是<em>另 一个地址</em>在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ <code>-e</code>选项常在这种情况下使用，也可采用<code>-P0</code>选项。</p>\n</li>\n<li><p><code>-e &lt;interface&gt;</code> (使用指定的接口)</p>\n<p>告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。</p>\n</li>\n<li><p><code>--source-port &lt;portnumber&gt;;</code> <code>-g &lt;portnumber&gt;</code> (源端口哄骗)</p>\n<p>仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。Nmap提供了<code>-g</code>和<code>--source-port</code>选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略<code>--source-port</code>选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。</p>\n</li>\n<li><p><code>--data-length &lt;number&gt;</code> (发送报文时 附加随机数据)</p>\n<p>正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(<code>-O</code>)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。</p>\n</li>\n<li><p><code>--ttl &lt;value&gt;</code> (设置IP time-to-live域)</p>\n<p>设置IPv4报文的time-to-live域为指定的值。</p>\n</li>\n<li><p><code>--randomize-hosts</code> (对目标主机的顺序随机排列)</p>\n<p>告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大<code>nmap.h</code>文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (<code>-sL -n -oN*&lt;filename&gt;*</code>)，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用<code>-iL</code>提供给Nmap。</p>\n</li>\n<li><p><code>--spoof-mac &lt;mac address，prefix，or vendor name&gt;</code> (MAC地址哄骗)</p>\n<p>要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 <code>--send-eth</code>选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过<code>nmap-mac-prefixes</code>查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的<code>--spoof-mac</code>参数有， <code>Apple</code>， <code>0</code>，<code>01:02:03:04:05:06</code>， <code>deadbeefcafe</code>，<code>0020F2</code>， 和<code>Cisco</code>.</p>\n</li>\n</ul>\n<h1 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h1><p>任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和 易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些 方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理 的XML格式。</p>\n<p>除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。</p>\n<p>Nmap提供5种不同的输出格式。默认的方式是<code>interactive output</code>， 发送给标准输出(stdout)。<code>normal output</code>方式类似于 <code>interactive</code>，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。</p>\n<p>XML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。</p>\n<p>另两种输出类型比较简单，<code>grepable output</code>格式，在一行中包含目标主机最多的信息；<code>sCRiPt KiDDi3 0utPUt</code> 格式，用于考虑自己的用户 |&lt;-r4d。</p>\n<p>交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项<code>-oX myscan.xml -oN myscan.nmap</code>。 为便于描述的简化，本章使用类似于<code>myscan.xml</code>的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。</p>\n<p>在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令<strong>nmap -oX myscan.xml target</strong>将 输出XML至<code>myscan.xml</code>，并在stdout 上打印相同的交互式结果，而此时<code>-oX</code>选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令<strong>nmap -oX - target</strong>只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。</p>\n<p>与其它Nmap参数不同，日志文件选项的空格(如<code>-oX</code>)和 文件名或连字符是必需的。如果省略了标记，例如<code>-oG-</code>或 <code>-oXscan.xml</code>，Nmap的向后兼容特点将建立 <em>标准格式</em>的输出文件，相应的文件名为<code>G-</code>和 <code>Xscan.xml</code>。</p>\n<p>Nmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项 如下所述。</p>\n<p><strong>Nmap输出格式</strong></p>\n<ul>\n<li><p><code>-oN &lt;filespec&gt;</code> (标准输出)</p>\n<p>要求将<code>标准输出</code>直接写入指定 的文件。如上所述，这个格式与<code>交互式输出</code> 略有不同。</p>\n</li>\n<li><p><code>-oX &lt;filespec&gt;</code> (XML输出)</p>\n<p>要求<code>XML输出</code>直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在 <a href=\"https://nmap.org/data/nmap.dtd获取。XML提供了可供软件解析的稳定格式输出，主要的计算机\" target=\"_blank\" rel=\"noopener\">https://nmap.org/data/nmap.dtd获取。XML提供了可供软件解析的稳定格式输出，主要的计算机</a> 语言都提供了免费的XML解析器，如C/C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的<a href=\"http://sourceforge.net/projects/nmap-scanner/\" target=\"_blank\" rel=\"noopener\">Nmap::Scanner</a> 和<a href=\"http://www.nmapparser.com/\" target=\"_blank\" rel=\"noopener\">Nmap::Parser</a>。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。XML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于<code>nmap.xsl</code>文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，<code>--stylesheet</code> 选项可用于建立可移植的XML文件。</p>\n</li>\n<li><p><code>-oS &lt;filespec&gt;</code> (ScRipT KIdd|3 oUTpuT)</p>\n<p>脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 ‘l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。</p>\n</li>\n<li><p><code>-oG &lt;filespec&gt;</code> (Grep输出)</p>\n<p>这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。Grep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有<code>主机</code>，<code>端口</code>， <code>协议</code>，<code>忽略状态</code>， <code>操作系统</code>，<code>序列号</code>， <code>IPID</code>和<code>状态</code>。这些域中最重要的是<code>Ports</code>，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由/分隔。这些子域有：<code>端口号</code>， <code>状态</code>，<code>协议</code>， <code>拥有者</code>，<code>服务</code>， <code>SunRPCinfo</code>和<code>版本信息</code>。对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可 查阅<a href=\"http://www.unspecific.com/nmap-oG-output。\" target=\"_blank\" rel=\"noopener\">http://www.unspecific.com/nmap-oG-output。</a></p>\n</li>\n<li><p><code>-oA &lt;basename&gt;</code> (输出至所有格式)</p>\n<p>为使用方便，利用<code>-oA*&lt;basename&gt;*</code>选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 *<basename><em>.nmap，</em><basename><em>.xml和 *<basename></basename></em>.gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用<code>~/nmaplogs/foocorp/</code>， 在Window中，使用<code>c:\\hacking\\sco</code> on Windows。</basename></basename></p>\n</li>\n</ul>\n<p><strong>细节和调试选项</strong></p>\n<ul>\n<li><p><code>-v</code> (提高输出信息的详细度)</p>\n<p>通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。</p>\n</li>\n<li><p><code>-d [level]</code> (提高或设置调试级别)</p>\n<p>当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(<code>-v</code>)时，可启用命令行参数 (<code>-d</code>)，多次使用可提高调试级别。也可在<code>-d</code> 后面使用参数设置调试级别。例如，<code>-d9</code>设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，<code>Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 ==&gt; srtt: 14987 rttvar: 14987 to: 100000</code>。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。</p>\n</li>\n<li><p><code>--packet-trace</code> (跟踪发送和接收的报文)</p>\n<p>要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如<code>-p20-30</code>。 如果只需进行版本检测，使用<code>--version-trace</code>。</p>\n</li>\n<li><p><code>--iflist</code> (列举接口和路由)</p>\n<p>输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。</p>\n</li>\n</ul>\n<p><strong>其它输出选项</strong></p>\n<ul>\n<li><p><code>--append-output</code> (在输出文件中添加)</p>\n<p>当使用文件作为输出格式，如<code>-oX</code>或<code>-oN</code>， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用<code>--append-output</code>选项。所有指 定的输出文件都被添加。但对于XML(<code>-oX</code>)扫描输出 文件无效，无法正常解析，需要手工修改。</p>\n</li>\n<li><p><code>--resume &lt;filename&gt;</code> (继续中断的扫描)</p>\n<p>一些扩展的Nmap运行需要很长的时间 – 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下<strong>ctrl-C</strong> 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (<code>-oN</code>)或Grep扫描(<code>-oG</code>)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 <code>--resume</code>并说明标准/Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如<strong>nmap –resume <logfilename></logfilename></strong>。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。</p>\n</li>\n<li><p><code>--stylesheet &lt;path or URL&gt;</code> (设置XSL样式表，转换XML输出)</p>\n<p>Nmap提从了XSL样式表<code>nmap.xsl</code>，用于查看 或转换XML输出至HTML。XML输出包含了一个<code>xml-stylesheet</code>， 直接指向<code>nmap.xml</code>文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找<code>nmap.xsl</code>文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 <code>--stylesheet</code>的参数，必段指明完整的路 径或URL，常见的调用方式是<code>--stylesheet https://nmap.org/data/nmap.xsl</code>。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和<code>nmap.xsl</code>) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。</p>\n</li>\n<li><p><code>--no-stylesheet</code> (忽略XML声明的XSL样式表)</p>\n<p>使用该选项禁止Nmap的XML输出关联任何XSL样式表。 <code>xml-stylesheet</code>指示被忽略。</p>\n</li>\n</ul>\n<h1 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h1><p>本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。</p>\n<ul>\n<li><p><code>-6</code> (启用IPv6扫描)</p>\n<p>从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加<code>-6</code>选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如<code>3ffe:7501:4819:2000:210:f3ff:fe03:14d0</code>。 除“所关注的端口”行的地址部分为IPv6地址。IPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于<a href=\"https://tb.ipv6.btexact.com/。\" target=\"_blank\" rel=\"noopener\">https://tb.ipv6.btexact.com/。</a> 此外，还有Hurricane Electric，位于<a href=\"http://ipv6tb.he.net/。6to4隧道是\" target=\"_blank\" rel=\"noopener\">http://ipv6tb.he.net/。6to4隧道是</a> 另一种常用的免费方法。</p>\n</li>\n<li><p><code>-A</code> (激烈扫描模式选项)</p>\n<p>这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(<code>-O</code>) 和版本扫描(<code>-sV</code>)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如<code>-T4</code>)或细节选项(<code>-v</code>)。</p>\n</li>\n<li><p><code>--datadir &lt;directoryname&gt;</code> (说明用户Nmap数据文件位置)</p>\n<p>Nmap在运行时从文件中获得特殊的数据，这些文件有 <code>nmap-service-probes</code>， <code>nmap-services</code>， <code>nmap-protocols</code>， <code>nmap-rpc</code>， <code>nmap-mac-prefixes</code>和 <code>nmap-os-fingerprints</code>。Nmap首先 在<code>--datadir</code>选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的<code>~/.nmap</code> 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如<code>/usr/local/share/nmap</code>或<code>/usr/share/nmap</code>。 Nmap查找的最后一个位置是当前目录。</p>\n</li>\n<li><p><code>--send-eth</code> (使用原以太网帧发送)</p>\n<p>要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。</p>\n</li>\n<li><p><code>--send-ip</code> (在原IP层发送)</p>\n<p>要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是<code>--send-eth</code>选项的补充。</p>\n</li>\n<li><p><code>--privileged</code> (假定用户具有全部权限)</p>\n<p>告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 <code>--privileged</code>在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于<code>--privileged</code>选项。</p>\n</li>\n<li><p><code>-V</code>; <code>--version</code> (打印版本信息)</p>\n<p>打印Nmap版本号并退出。</p>\n</li>\n<li><p><code>-h</code>; <code>--help</code> (打印帮助摘要面)</p>\n<p>打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。</p>\n</li>\n</ul>\n<h1 id=\"运行时交互\"><a href=\"#运行时交互\" class=\"headerlink\" title=\"运行时交互\"></a>运行时交互</h1><p><em>Nmap目前还不具有这个功能，本节内容可能会增加或删除。</em></p>\n<p>在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，<em>小写字母增加</em> 打印量，<em>大写字母减少</em>打印量。</p>\n<ul>\n<li><p><code>v</code> / <code>V</code></p>\n<p>增加 / 减少细节</p>\n</li>\n<li><p><code>d</code> / <code>D</code></p>\n<p>提高 / 降低调试级别</p>\n</li>\n<li><p><code>p</code> / <code>P</code></p>\n<p>打开/ 养老报文跟踪</p>\n</li>\n<li><p>其它</p>\n<p>打印的信息类似于：Stats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service ScanService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)</p>\n</li>\n</ul>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><p>下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用<em>你自己网络</em> 的地址/域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。</p>\n<p>如果是为了测试，<code>scanme.nmap.org</code> 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告<code>解析 指定的主机名/IP地址失败：scanme.nmap.org</code>。这些免 费扫描要求也适用于<code>scanme2.nmap.org</code>、 <code>scanme3.nmap.org</code>等等，虽然这些 主机目前还不存在。</p>\n<p><strong>nmap -v scanme.nmap.org</strong></p>\n<p>这个选项扫描主机<code>scanme.nmap.org</code>中 所有的保留TCP端口。选项<code>-v</code>启用细节模式。</p>\n<p><strong>nmap -sS -O scanme.nmap.org/24</strong></p>\n<p>进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。</p>\n<p><strong>nmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127</strong></p>\n<p>进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。</p>\n<p><strong>nmap -v -iR 100000 -P0 -p 80</strong></p>\n<p>随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用<code>-P0</code>禁止对主机列表。</p>\n<p><strong>nmap -P0 -p80 -oX logs/pb-port80scan.xml -oG logs/pb-port80scan.gnmap 216.163.128.20/20</strong></p>\n<p>扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。</p>\n<p><strong>host -l company.com | cut -d -f 4 | nmap -v -iL -</strong></p>\n<p>进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU/Linux – 其它系统进行区域传输时有不同的命令。</p>\n<h1 id=\"Bugs\"><a href=\"#Bugs\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h1><p>和作者一样，Nmap也不是完美的，但可以通过发送Bug报告甚至编写 补丁使其更加完善。如果Nmap不能满足要求，首先从<a href=\"https://nmap.org/\" target=\"_blank\" rel=\"noopener\">https://nmap.org/</a> 升级最新版本。如果总问题仍然存在，需要进行调查以确定问题是否 已经被解决。在<a href=\"http://seclists.org/尝试搜索出错消息或\" target=\"_blank\" rel=\"noopener\">http://seclists.org/尝试搜索出错消息或</a> 浏览Nmap-dev档案，以及仔细阅读使用手册。如果问题还是不能解决，发送 Bug报告至<code>&lt;dev@nmap.org&gt;</code>。在报告中包含所有 有关问题的信息，以及所使用的Nmap版本、操作系统版本。问题报告以及 Nmap的使用问题发送给<a href=\"mailto:dev@nmap.org\" target=\"_blank\" rel=\"noopener\">dev@nmap.org</a>比直接发送给Gyodor能更好回答。</p>\n<p>解决Bug的代码补丁比Bug报告更受欢迎，在<a href=\"https://nmap.org/data/HACKING\" target=\"_blank\" rel=\"noopener\">https://nmap.org/data/HACKING</a> 可获得建立补丁文件的基本指令。补丁可发送给nmap-dev(建议) 或直接发给Fyodor。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck2mke12u0000bfgaq64fz5zl","tag_id":"ck2mke1630002bfgaeeeb5lrn","_id":"ck2mke1670005bfgaof7snx64"},{"post_id":"ck2mke1650003bfga2xmpivhf","tag_id":"ck2mke1660004bfgan1p9bcom","_id":"ck2mke1670006bfgaj22iuu39"},{"post_id":"ck2mke16l0007bfgaveg60xdy","tag_id":"ck2mke16m0008bfga7ffp3tg2","_id":"ck2mke16m0009bfgaucp648sv"},{"post_id":"ck2mke18g000abfgakz6q5fo9","tag_id":"ck2mke18h000bbfgaz166qkbu","_id":"ck2mke18i000cbfgaoc5j2ir1"},{"post_id":"ck2mke1c1000dbfgaddclse4x","tag_id":"ck2mke1c3000ebfgavqn1hiqn","_id":"ck2mke1c3000fbfga85qelbbl"},{"post_id":"ck2mke1sa000gbfgaooo1p1yb","tag_id":"ck2mke1c3000ebfgavqn1hiqn","_id":"ck2mke1sc000hbfga8j19w4ow"}],"Tag":[{"name":"知识点记录","_id":"ck2mke1630002bfgaeeeb5lrn"},{"name":"iOS开发中的小技巧","_id":"ck2mke1660004bfgan1p9bcom"},{"name":"软件、工具的使用","_id":"ck2mke16m0008bfga7ffp3tg2"},{"name":"第三方的使用","_id":"ck2mke18h000bbfgaz166qkbu"},{"name":"工具的使用","_id":"ck2mke1c3000ebfgavqn1hiqn"}]}}